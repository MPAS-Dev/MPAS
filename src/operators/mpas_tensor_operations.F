! Copyright (c) 2013,  Los Alamos National Security, LLC (LANS) (LA-CC-13-047)
! and the University Corporation for Atmospheric Research (UCAR).
!
! Unless noted otherwise source code is licensed under the BSD license.
! Additional copyright and license information can be found in the LICENSE file
! distributed with this code, or at http://mpas-dev.github.com/license.html
!
!|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
!
!  mpas_tensor_operations
!
!> \brief MPAS tensor operations
!> \author Mark Petersen
!> \date    17 April 2013
!> \details
!>  This module contains the routines for computing
!>  the strain rate tensor, the divergence of a tensor,
!>  and a testing routine to verify these work properly.
!
!-----------------------------------------------------------------------

module mpas_tensor_operations

   use mpas_grid_types
   use mpas_constants
   use mpas_configure
   use mpas_vector_operations
   use mpas_matrix_operations

   implicit none
   private
   save

   !--------------------------------------------------------------------
   !
   ! Public parameters
   !
   !--------------------------------------------------------------------

   !--------------------------------------------------------------------
   !
   ! Public member functions
   !
   !--------------------------------------------------------------------

   public :: mpas_strain_rate_R3, &
             mpas_divergence_of_tensor_3D, &
             mpas_tensor_edge_R3_to_2D, &
             mpas_tensor_edge_2D_to_R3, &
             mpas_tensor_R3_to_LonLat, &
             mpas_tensor_LonLat_to_R3, &
             mpas_test_tensor

   !--------------------------------------------------------------------
   !
   ! Private module variables
   !
   !--------------------------------------------------------------------

!***********************************************************************

contains

!***********************************************************************
!
!  routine mpas_strain_rate_R3
!
!> \brief   Computes strain rate at cell centers, in R3
!> \author  Mark Petersen
!> \date    17 April 2013
!> \details 
!>  This routine computes the strain rate at cell centers using the weak 
!>  derivative.  Output is an R3 strain rate tensor in 6-index format.
!
!-----------------------------------------------------------------------

   subroutine mpas_strain_rate_R3(grid, normalVelocity, tangentialVelocity, &
      strainRateR3Cell, outerProductEdge)!{{{

      !-----------------------------------------------------------------
      !
      ! input variables
      !
      !-----------------------------------------------------------------

      real (kind=RKIND), dimension(:,:), intent(in) :: &
         normalVelocity, &!< Input: Horizontal velocity normal to edge
         tangentialVelocity   !< Input: Horizontal velocity tangent to edge

      type (mesh_type), intent(in) :: &
         grid          !< Input: grid information

      !-----------------------------------------------------------------
      !
      ! output variables
      !
      !-----------------------------------------------------------------

      real (kind=RKIND), dimension(:,:,:), intent(out) :: &
         strainRateR3Cell   !< Output: strain rate tensor at cell center, R3, in symmetric 6-index form

      real (kind=RKIND), dimension(:,:,:), intent(out) :: outerProductEdge


      !-----------------------------------------------------------------
      !
      ! local variables
      !
      !-----------------------------------------------------------------

      integer :: iEdge, nEdges, iCell, nCells, i,j,k

      integer, dimension(:), pointer :: maxLevelEdgeBot, nEdgesOnCell, maxLevelCell
      integer, dimension(:,:), pointer :: edgesOnCell, edgeSignOnCell

      real (kind=RKIND) :: invAreaCell
      real (kind=RKIND), dimension(3,3) :: outerProductEdge3x3
      real (kind=RKIND), dimension(:), pointer :: dvEdge, areaCell, angleEdge
      real (kind=RKIND), dimension(:,:), pointer :: edgeNormalVectors, edgeTangentVectors

      nEdges = grid % nEdges
      nCells = grid % nCells

      maxLevelEdgeBot   => grid % maxLevelEdgeBot % array
      maxLevelCell      => grid % maxLevelCell % array
      nEdgesOnCell      => grid % nEdgesOnCell % array
      edgesOnCell       => grid % edgesOnCell % array
      edgeSignOnCell    => grid % edgeSignOnCell % array
      dvEdge            => grid % dvEdge % array
      angleEdge         => grid % angleEdge % array
      areaCell          => grid % areaCell % array
      edgeNormalVectors  => grid % edgeNormalVectors % array
      edgeTangentVectors => grid % edgeTangentVectors % array

      do iEdge=1,nEdges
         ! mrp question: for this to be general across cores, we need to use nVertLevels
         do k=1,maxLevelEdgeBot(iEdge)
           do i=1,3
             do j=1,3
               ! outer produce at each edge:
               ! u_e n_e n_e* + v_e n_e \tilde{n}_e* 
               outerProductEdge3x3(i,j) = edgeNormalVectors(i,iEdge) &
                       *(  normalVelocity(k,iEdge)    *edgeNormalVectors(j,iEdge) &
                         + tangentialVelocity(k,iEdge)*edgeTangentVectors(j,iEdge) &
                           )
             enddo
           enddo
           call mpas_matrix_3x3_to_sym6index(outerProductEdge3x3,outerProductEdge(:,k,iEdge))
         enddo
      enddo

      strainRateR3Cell = 0.0
      do iCell = 1, nCells
         invAreaCell = 1.0 / areaCell(iCell)
         do i = 1, nEdgesOnCell(iCell)
            iEdge = edgesOnCell(i, iCell)
            do k = 1, maxLevelCell(iCell)
               ! mrp edgeSignOnCell is to get outward unit normal on edgeNormalVectors
               ! minus sign in front is to match form on divergence, below
               strainRateR3Cell(:,k,iCell) = strainRateR3Cell(:,k,iCell) &
                 - edgeSignOnCell(i,iCell)*outerProductEdge(:,k,iEdge)*invAreaCell*dvEdge(iEdge) 
            end do
         end do
      end do

   end subroutine mpas_strain_rate_R3!}}}

!***********************************************************************
!
!  routine mpas_divergence_of_tensor_3D
!
!> \brief   Computes divergence of the stress tensor
!> \author  Mark Petersen
!> \date    17 April 2013
!> \details 
!>  This routine computes the divergence of the stress tensor
!
!-----------------------------------------------------------------------

   subroutine mpas_divergence_of_tensor_3D(grid, strainRateR3Edge, divTensorR3Cell)!{{{

      !-----------------------------------------------------------------
      !
      ! input variables
      !
      !-----------------------------------------------------------------

      real (kind=RKIND), dimension(:,:,:), intent(in) :: &
         strainRateR3Edge  !< Input: tensor at edge, R3, in symmetric 6-index form

      type (mesh_type), intent(in) :: &
         grid          !< Input: grid information

      !-----------------------------------------------------------------
      !
      ! output variables
      !
      !-----------------------------------------------------------------

      real (kind=RKIND), dimension(:,:,:), intent(out) :: &
         divTensorR3Cell  !< Output: divergence of the tensor at cell center, 
                          !< as a 3-vector in x,y,z space

      !-----------------------------------------------------------------
      !
      ! local variables
      !
      !-----------------------------------------------------------------

      integer :: iEdge, nEdges, iCell, nCells, i,j,k,p,q

      integer, dimension(:), pointer :: nEdgesOnCell, maxLevelCell
      integer, dimension(:,:), pointer :: edgesOnCell, edgeSignOnCell

      real (kind=RKIND) :: invAreaCell
      real (kind=RKIND), dimension(3) :: edgeNormalDotTensor
      real (kind=RKIND), dimension(3,3) :: strainRateR3Edge3x3
      real (kind=RKIND), dimension(:), pointer :: dvEdge, areaCell
      real (kind=RKIND), dimension(:,:), pointer :: edgeNormalVectors

      nEdges = grid % nEdges
      nCells = grid % nCells

      maxLevelCell      => grid % maxLevelCell % array
      edgesOnCell       => grid % edgesOnCell % array
      nEdgesOnCell      => grid % nEdgesOnCell % array
      dvEdge            => grid % dvEdge % array
      areaCell          => grid % areaCell % array
      edgeNormalVectors  => grid % edgeNormalVectors % array
      edgeSignOnCell    => grid % edgeSignOnCell % array

      divTensorR3Cell(:,:,:) = 0.0
      do iCell = 1, nCells
         invAreaCell = 1.0 / areaCell(iCell)
         do i = 1, nEdgesOnCell(iCell)
            iEdge = edgesOnCell(i, iCell)
            do k = 1, maxLevelCell(iCell)
               call mpas_matrix_sym6index_to_3x3(strainRateR3Edge(:,k,iEdge),strainRateR3Edge3x3)
               edgeNormalDotTensor(:) = 0.0
               do q=1,3
                 do p=1,3
                   edgeNormalDotTensor(q) = edgeNormalDotTensor(q) + edgeNormalVectors(p,iEdge)*strainRateR3Edge3x3(p,q)
                 enddo
               enddo
               divTensorR3Cell(:,k,iCell) = divTensorR3Cell(:,k,iCell) &
                 - edgeSignOnCell(i,iCell) * dvEdge(iEdge) * edgeNormalDotTensor(:) * invAreaCell
            end do
         end do
      end do

   end subroutine mpas_divergence_of_tensor_3D!}}}

!***********************************************************************
!
!  routine mpas_tensor_edge_R3_to_2D
!
!> \brief   Convert an R3 tensor to a 2D tensor, at an edge
!> \author  Mark Petersen
!> \date    17 April 2013
!> \details 
!>  Given an R3 tensor in symetric 6-index form, this routine rotates
!>  the tensor so that the 1-direction is towards the edge normal, and 
!>  the 2-direction is towards the edge tangent, and returns a 2D
!>  tensor in symmetric 3-index form. 
!
!-----------------------------------------------------------------------

   subroutine mpas_tensor_edge_R3_to_2D(strainRateR3Edge, strainRate2DEdge, grid)!{{{

      !-----------------------------------------------------------------
      !
      ! input variables
      !
      !-----------------------------------------------------------------

      real (kind=RKIND), dimension(:,:,:), intent(in) :: &
         strainRateR3Edge  !< Input: strain rate tensor at edge, R3, in symmetric 6-index form

      type (mesh_type), intent(in) :: &
         grid          !< Input: grid information

      !-----------------------------------------------------------------
      !
      ! output variables
      !
      !-----------------------------------------------------------------

      real (kind=RKIND), dimension(:,:,:), intent(out) :: &
         strainRate2DEdge   !< Output: strain rate tensor at edge, 2D, in symmetric 3-index form

      !-----------------------------------------------------------------
      !
      ! local variables
      !
      !-----------------------------------------------------------------

      integer :: iEdge, nEdges, i,j,k,p,q, nVertLevels
      integer, dimension(:), pointer :: maxLevelEdgeBot

      real (kind=RKIND), dimension(3) :: edgeVerticalVector
      real (kind=RKIND), dimension(3,3) :: rotationMatrix, strainRateR3Edge3x3, strainRateR3Edge3x3Rotated
      real (kind=RKIND), dimension(:,:), pointer :: edgeNormalVectors, edgeTangentVectors

      nEdges = grid % nEdges
      nVertLevels = grid % nVertLevels

      maxLevelEdgeBot   => grid % maxLevelEdgeBot % array
      edgeNormalVectors  => grid % edgeNormalVectors % array
      edgeTangentVectors => grid % edgeTangentVectors % array

      do iEdge=1,nEdges

         ! compute vertical vector at edge
         call mpas_cross_product_in_r3(edgeNormalVectors(:,iEdge),edgeTangentVectors(:,iEdge),edgeVerticalvector)

         rotationMatrix(:,1) = edgeNormalVectors(:,iEdge)
         rotationMatrix(:,2) = edgeTangentVectors(:,iEdge)
         rotationMatrix(:,3) = edgeVerticalvector

         ! mrp question: for this to be general across cores, we need to use nVertLevels
         do k=1,maxLevelEdgeBot(iEdge)
 
           call mpas_matrix_sym6index_to_3x3(strainRateR3Edge(:,k,iEdge),strainRateR3Edge3x3)

           ! If I were convinced everything is correct, could just compute i=1,2 and j=1,i
           strainRateR3Edge3x3Rotated = 0.0
           do i=1,3
             do j=1,3
               do p=1,3
                 do q=1,3
                    ! I'm not sure if the star should be on the first or third matrix.
                    ! Here it is on the first
                    strainRateR3Edge3x3Rotated(i,j) = strainRateR3Edge3x3Rotated(i,j) + rotationMatrix(p,i)*strainRateR3Edge3x3(p,q)*rotationMatrix(q,j)
                 enddo
               enddo
             enddo
           enddo

           strainRate2DEdge(1,k,iEdge) = strainRateR3Edge3x3Rotated(1,1)
           strainRate2DEdge(2,k,iEdge) = strainRateR3Edge3x3Rotated(2,2)
           strainRate2DEdge(3,k,iEdge) = 0.5*(strainRateR3Edge3x3Rotated(1,2) + strainRateR3Edge3x3Rotated(2,1))
           ! mrp set land edges to zero?
         enddo

      enddo

   end subroutine mpas_tensor_edge_R3_to_2D!}}}

!***********************************************************************
!
!  routine mpas_tensor_edge_2D_to_R3
!
!> \brief   Convert a 2D tensor to a tensor in R3, at an edge
!> \author  Mark Petersen
!> \date    17 April 2013
!> \details 
!>  Given a 2D tensor in symetric 3-index form that is rotated such that
!>  the 1-direction is towards the edge normal, and 
!>  the 2-direction is towards the edge tangent, this routine rotates
!>  the tensor to R3, and returns an R3 tensor in symetric 6-index form.
!
!-----------------------------------------------------------------------

   subroutine mpas_tensor_edge_2D_to_R3(strainRate2DEdge, strainRateR3Edge, grid)!{{{

      !-----------------------------------------------------------------
      !
      ! input variables
      !
      !-----------------------------------------------------------------

      real (kind=RKIND), dimension(:,:,:), intent(in) :: &
         strainRate2DEdge   !< Input: strain rate tensor at edge, 2D, in symmetric 3-index form

      type (mesh_type), intent(in) :: &
         grid          !< Input: grid information

      !-----------------------------------------------------------------
      !
      ! output variables
      !
      !-----------------------------------------------------------------

      real (kind=RKIND), dimension(:,:,:), intent(out) :: &
         strainRateR3Edge  !< Output: strain rate tensor at edge, R3, in symmetric 6-index form

      !-----------------------------------------------------------------
      !
      ! local variables
      !
      !-----------------------------------------------------------------

      integer :: iEdge, nEdges, i,j,k,p,q, nVertLevels
      integer, dimension(:), pointer :: maxLevelEdgeBot

      real (kind=RKIND), dimension(3) :: edgeVerticalVector
      real (kind=RKIND), dimension(3,3) :: rotationMatrix, strainRateR3Edge3x3, strainRateR3Edge3x3Rotated
      real (kind=RKIND), dimension(:,:), pointer :: edgeNormalVectors, edgeTangentVectors

      nEdges = grid % nEdges
      nVertLevels = grid % nVertLevels
      maxLevelEdgeBot   => grid % maxLevelEdgeBot % array
      edgeNormalVectors  => grid % edgeNormalVectors % array
      edgeTangentVectors => grid % edgeTangentVectors % array

      do iEdge=1,nEdges

         ! compute vertical vector at edge
         call mpas_cross_product_in_r3(edgeNormalVectors(:,iEdge),edgeTangentVectors(:,iEdge),edgeVerticalVector)

         rotationMatrix(:,1) = edgeNormalVectors(:,iEdge)
         rotationMatrix(:,2) = edgeTangentVectors(:,iEdge)
         rotationMatrix(:,3) = edgeVerticalVector

         ! mrp question: for this to be general across cores, we need to use nVertLevels
         do k=1,maxLevelEdgeBot(iEdge)

           strainRateR3Edge3x3Rotated = 0.0
           strainRateR3Edge3x3Rotated(1,1) = strainRate2DEdge(1,k,iEdge) 
           strainRateR3Edge3x3Rotated(2,2) = strainRate2DEdge(2,k,iEdge) 
           strainRateR3Edge3x3Rotated(1,2) = strainRate2DEdge(3,k,iEdge) 
           strainRateR3Edge3x3Rotated(2,1) = strainRate2DEdge(3,k,iEdge) 

           strainRateR3Edge3x3 = 0.0
           do i=1,3
             do j=1,3
               do p=1,3
                 do q=1,3
                    ! I'm not sure if the star should be on the first or third matrix.
                    ! Here it is on the third
                    strainRateR3Edge3x3(i,j) = strainRateR3Edge3x3(i,j) + rotationMatrix(i,p)*strainRateR3Edge3x3Rotated(p,q)*rotationMatrix(j,q)
                 enddo
               enddo
             enddo
           enddo
 
           call mpas_matrix_3x3_to_sym6index(strainRateR3Edge3x3,strainRateR3Edge(:,k,iEdge))

           ! mrp set land edges to zero?
         enddo

      enddo

   end subroutine mpas_tensor_edge_2D_to_R3!}}}


!***********************************************************************
!
!  routine mpas_tensor_LonLat_to_R3
!
!> \brief   Convert an R3 tensor to a 2D tensor
!> \author  Mark Petersen
!> \date    17 April 2013
!> \details 
!>  Given a 2D tensor in symetric 3-index form that is rotated such that
!>  the 1-direction is zonal
!>  the 2-direction is meridional, this routine rotates
!>  the tensor to R3, and returns an R3 tensor in symetric 6-index form.
!
!-----------------------------------------------------------------------

   subroutine mpas_tensor_LonLat_to_R3(strainRateLonLat, strainRateR3, lon, lat)!{{{

      !-----------------------------------------------------------------
      !
      ! input variables
      !
      !-----------------------------------------------------------------

      real (kind=RKIND), dimension(3), intent(in) :: &
         strainRateLonLat   !< Input: strain rate tensor, 2D, in symmetric 3-index form

      real (kind=RKIND), intent(in) :: &
         lon, &!< Input: longitude, in radians, ranging [0,2*pi]
         lat   !< Input: latitude,  in radians, ranging [-pi,pi]
 
      !-----------------------------------------------------------------
      !
      ! output variables
      !
      !-----------------------------------------------------------------

      real (kind=RKIND), dimension(6), intent(out) :: &
         strainRateR3  !< Output: strain rate tensor, R3, in symmetric 6-index form

      !-----------------------------------------------------------------
      !
      ! local variables
      !
      !-----------------------------------------------------------------

      integer :: i,j,k,p,q, nVertLevels

      real (kind=RKIND) :: determinant
      real (kind=RKIND), dimension(3) :: zonalUnitVector, meridionalUnitVector, verticalUnitVector
      real (kind=RKIND), dimension(3,3) :: rotationMatrix, strainRateR3_3x3, strainRateLonLat3x3

      call mpas_zonal_meridional_vectors(lon, lat, zonalUnitVector, meridionalUnitVector, verticalUnitVector)

      rotationMatrix(:,1) = zonalUnitVector
      rotationMatrix(:,2) = meridionalUnitVector
      rotationMatrix(:,3) = verticalUnitVector

      strainRateLonLat3x3 = 0.0
      strainRateLonLat3x3(1,1) = strainRateLonLat(1)
      strainRateLonLat3x3(2,2) = strainRateLonLat(2)
      strainRateLonLat3x3(1,2) = strainRateLonLat(3)
      strainRateLonLat3x3(2,1) = strainRateLonLat(3)

      strainRateR3_3x3 = 0.0
      do i=1,3
        do j=1,3
          do p=1,3
            do q=1,3
               strainRateR3_3x3(i,j) = strainRateR3_3x3(i,j) + rotationMatrix(i,p)*strainRateLonLat3x3(p,q)*rotationMatrix(j,q)
            enddo
          enddo
        enddo
      enddo
 
      call mpas_matrix_3x3_to_sym6index(strainRateR3_3x3,strainRateR3)

   end subroutine mpas_tensor_LonLat_to_R3!}}}


!***********************************************************************
!
!  routine mpas_tensor_LonLatR_to_R3
!
!> \brief   Convert an R3 tensor to a 2D tensor
!> \author  Mark Petersen
!> \date    17 April 2013
!> \details 
!>  Given a 3D tensor in symetric 6-index form that is rotated such that
!>  the 1-direction is zonal
!>  the 2-direction is meridional, 
!>  the 3-direction is radial, this routine rotates
!>  the tensor to R3, and returns an R3 tensor in symetric 6-index form.
!
!-----------------------------------------------------------------------

   subroutine mpas_tensor_LonLatR_to_R3(tensorLonLatR, strainRateR3, lon, lat)!{{{

      !-----------------------------------------------------------------
      !
      ! input variables
      !
      !-----------------------------------------------------------------

      real (kind=RKIND), dimension(6), intent(in) :: &
         tensorLonLatR   !< Input: latlon strain rate tensor, 3D, in symmetric 6-index form

      real (kind=RKIND), intent(in) :: &
         lon, &!< Input: longitude, in radians, ranging [0,2*pi]
         lat   !< Input: latitude,  in radians, ranging [-pi,pi]
 
      !-----------------------------------------------------------------
      !
      ! output variables
      !
      !-----------------------------------------------------------------

      real (kind=RKIND), dimension(6), intent(out) :: &
         strainRateR3  !< Output: strain rate tensor, R3, in symmetric 6-index form

      !-----------------------------------------------------------------
      !
      ! local variables
      !
      !-----------------------------------------------------------------

      integer :: i,j,k,p,q, nVertLevels

      real (kind=RKIND) :: determinant
      real (kind=RKIND), dimension(3) :: zonalUnitVector, meridionalUnitVector, verticalUnitVector
      real (kind=RKIND), dimension(3,3) :: rotationMatrix, strainRateR3_3x3, tensorLonLatR3x3, A

      call mpas_zonal_meridional_vectors(lon, lat, zonalUnitVector, meridionalUnitVector, verticalUnitVector)

      rotationMatrix(:,1) = zonalUnitVector
      rotationMatrix(:,2) = meridionalUnitVector
      rotationMatrix(:,3) = verticalUnitVector

      call mpas_matrix_sym6index_to_3x3(tensorLonLatR,tensorLonLatR3x3)

      strainRateR3_3x3 = 0.0
      do i=1,3
        do j=1,3
          do p=1,3
            do q=1,3
               strainRateR3_3x3(i,j) = strainRateR3_3x3(i,j) + rotationMatrix(i,p)*tensorLonLatR3x3(p,q)*rotationMatrix(j,q)
            enddo
          enddo
        enddo
      enddo
 
      call mpas_matrix_3x3_to_sym6index(strainRateR3_3x3,strainRateR3)

   end subroutine mpas_tensor_LonLatR_to_R3!}}}

!***********************************************************************
!
!  routine mpas_tensor_R3_to_LonLat
!
!> \brief   Convert an R3 tensor to a 2D tensor
!> \author  Mark Petersen
!> \date    17 April 2013
!> \details 
!>  Given a 2D tensor in symetric 3-index form that is rotated such that
!>  the 1-direction is zonal
!>  the 2-direction is meridional, this routine rotates
!>  the tensor to R3, and returns an R3 tensor in symetric 6-index form.
!
!-----------------------------------------------------------------------

   subroutine mpas_tensor_R3_to_LonLat(strainRateR3, strainRateLonLat, lon, lat)!{{{

      !-----------------------------------------------------------------
      !
      ! input variables
      !
      !-----------------------------------------------------------------

      real (kind=RKIND), dimension(6), intent(in) :: &
         strainRateR3  !< Input: strain rate tensor at, R3, in symmetric 6-index form

      real (kind=RKIND), intent(in) :: &
         lon, &!< Input: longitude, in radians, ranging [0,2*pi]
         lat   !< Input: latitude,  in radians, ranging [-pi,pi]
 
      !-----------------------------------------------------------------
      !
      ! output variables
      !
      !-----------------------------------------------------------------

      real (kind=RKIND), dimension(3), intent(out) :: &
         strainRateLonLat   !< Output: strain rate tensor, 2D, in symmetric 3-index form

      !-----------------------------------------------------------------
      !
      ! local variables
      !
      !-----------------------------------------------------------------

      integer :: i,j,k,p,q

      real (kind=RKIND), dimension(3) :: zonalUnitVector, meridionalUnitVector, verticalUnitVector
      real (kind=RKIND), dimension(3,3) :: rotationMatrix, strainRateR3_3x3, strainRateLonLat3x3

      call mpas_zonal_meridional_vectors(lon, lat, zonalUnitVector, meridionalUnitVector, verticalUnitVector)

      rotationMatrix(:,1) = zonalUnitVector
      rotationMatrix(:,2) = meridionalUnitVector
      rotationMatrix(:,3) = verticalUnitVector

      call mpas_matrix_sym6index_to_3x3(strainRateR3,strainRateR3_3x3)

      strainRateLonLat3x3 = 0
      do i=1,3
        do j=1,3
          do p=1,3
            do q=1,3
               strainRateLonLat3x3(i,j) = strainRateLonLat3x3(i,j) + rotationMatrix(p,i)*strainRateR3_3x3(p,q)*rotationMatrix(q,j)
            enddo
          enddo
        enddo
      enddo
 
      strainRateLonLat(1) = strainRateLonLat3x3(1,1)
      strainRateLonLat(2) = strainRateLonLat3x3(2,2)
      strainRateLonLat(3) = 0.5*(strainRateLonLat3x3(1,2)+strainRateLonLat3x3(2,1))

   end subroutine mpas_tensor_R3_to_LonLat!}}}


!***********************************************************************
!
!  routine mpas_tensor_R3_to_LonLatR
!
!> \brief   Convert an R3 tensor to a 2D tensor
!> \author  Mark Petersen
!> \date    17 April 2013
!> \details 
!>  Given a 2D tensor in symetric 3-index form that is rotated such that
!>  the 1-direction is zonal
!>  the 2-direction is meridional, this routine rotates
!>  the tensor to R3, and returns an R3 tensor in symetric 6-index form.
!
!-----------------------------------------------------------------------

   subroutine mpas_tensor_R3_to_LonLatR(strainRateR3, tensorLonLatR, lon, lat)!{{{

      !-----------------------------------------------------------------
      !
      ! input variables
      !
      !-----------------------------------------------------------------

      real (kind=RKIND), dimension(6), intent(in) :: &
         strainRateR3  !< Input: strain rate tensor at, R3, in symmetric 6-index form

      real (kind=RKIND), intent(in) :: &
         lon, &!< Input: longitude, in radians, ranging [0,2*pi]
         lat   !< Input: latitude,  in radians, ranging [-pi,pi]
 
      !-----------------------------------------------------------------
      !
      ! output variables
      !
      !-----------------------------------------------------------------

      real (kind=RKIND), dimension(6), intent(out) :: &
         tensorLonLatR   !< Output: strain rate tensor, 3D lat-lon coord, in symmetric 6-index form

      !-----------------------------------------------------------------
      !
      ! local variables
      !
      !-----------------------------------------------------------------

      integer :: i,j,k,p,q

      real (kind=RKIND), dimension(3) :: zonalUnitVector, meridionalUnitVector, verticalUnitVector
      real (kind=RKIND), dimension(3,3) :: rotationMatrix, strainRateR3_3x3, strainRateLonLat3x3

      call mpas_zonal_meridional_vectors(lon, lat, zonalUnitVector, meridionalUnitVector, verticalUnitVector)

      rotationMatrix(:,1) = zonalUnitVector
      rotationMatrix(:,2) = meridionalUnitVector
      rotationMatrix(:,3) = verticalUnitVector

      call mpas_matrix_sym6index_to_3x3(strainRateR3,strainRateR3_3x3)

      strainRateLonLat3x3 = 0
      do i=1,3
        do j=1,3
          do p=1,3
            do q=1,3
               strainRateLonLat3x3(i,j) = strainRateLonLat3x3(i,j) + rotationMatrix(p,i)*strainRateR3_3x3(p,q)*rotationMatrix(q,j)
            enddo
          enddo
        enddo
      enddo

      call mpas_matrix_3x3_to_sym6index(strainRateLonLat3x3,tensorLonLatR)

   end subroutine mpas_tensor_R3_to_LonLatR!}}}

!***********************************************************************
!
!  routine mpas_strain_rate_LonLat
!
!> \brief   Computes strain rate at cells and vertices
!> \author  Mark Petersen
!> \date    25 September 2012
!> \version SVN:$Id$
!> \details 
!>  This routine computes the strain rate at the cell centers and 
!>  vertices using the weak derivative.
!
!-----------------------------------------------------------------------

   subroutine mpas_strain_rate_LonLat(grid, normalVelocity,tangentialVelocity, strainRate2DCell, strainRate2DVertex)!{{{

      !-----------------------------------------------------------------
      !
      ! input variables
      !
      !-----------------------------------------------------------------

      real (kind=RKIND), dimension(:,:), intent(in) :: &
         normalVelocity, &!< Input: Horizontal velocity normal to edge
         tangentialVelocity   !< Input: Horizontal velocity tangent to edge

      type (mesh_type), intent(in) :: &
         grid          !< Input: grid information

      !-----------------------------------------------------------------
      !
      ! input/output variables
      !
      !-----------------------------------------------------------------

      !-----------------------------------------------------------------
      !
      ! output variables
      !
      !-----------------------------------------------------------------

      real (kind=RKIND), dimension(:,:,:), intent(out) :: &
         strainRate2DCell  !< Output: strain rate tensor at cell center
      real (kind=RKIND), dimension(:,:,:), intent(out) :: &
         strainRate2DVertex  !< Output: strain rate tensor at vertex

      !-----------------------------------------------------------------
      !
      ! local variables
      !
      !-----------------------------------------------------------------

      integer :: iEdge, nEdges, nCells,nVertices, cell1, cell2, vertex1, vertex2, k

      integer, dimension(:), pointer :: maxLevelEdgeBot
      integer, dimension(:,:), pointer :: cellsOnEdge, verticesOnEdge

      real (kind=RKIND) :: invAreaCell1, invAreaCell2, invAreaTri1, invAreaTri2, &
        cos_pwr1, sin_pwr1, cos_pwr2, sin_pwr2, cossin, uDvEdge, uDcEdge, eps11, eps22, eps12, nVertLevels
      real (kind=RKIND), dimension(:), pointer :: dvEdge, dcEdge, areaCell, areaTriangle, angleEdge

      !-----------------------------------------------------------------
      !
      ! call relevant routines for computing tendencies
      ! note that the user can choose multiple options and the 
      !   tendencies will be added together
      !
      !-----------------------------------------------------------------

      nEdges = grid % nEdges
      nCells = grid % nCells
      nVertices = grid % nVertices
      nVertLevels = grid % nVertLevels

      maxLevelEdgeBot   => grid % maxLevelEdgeBot % array
      cellsOnEdge => grid % cellsOnEdge % array
      verticesOnEdge    => grid % verticesOnEdge % array
      dcEdge            => grid % dcEdge % array
      dvEdge            => grid % dvEdge % array
      areaCell          => grid % areaCell % array
      areaTriangle      => grid % areaTriangle % array
      angleEdge         => grid % angleEdge % array

      strainRate2DCell = 0.0
      strainRate2DVertex  = 0.0

      do iEdge=1,nEdges
         vertex1 = verticesOnEdge(1,iEdge)
         vertex2 = verticesOnEdge(2,iEdge)

         cell1 = cellsOnEdge(1,iEdge)
         cell2 = cellsOnEdge(2,iEdge)

         invAreaTri1 = 1.0 / areaTriangle(vertex1)
         invAreaTri2 = 1.0 / areaTriangle(vertex2)

         !dwj: 02/23/12 arraCell(nCells+1) is still 0, this is a temporary fix
         invAreaCell1 = 1.0 / max(areaCell(cell1), 1e-10)
         invAreaCell2 = 1.0 / max(areaCell(cell2), 1e-10)

         cos_pwr1 = cos(angleEdge(iEdge))
         cos_pwr2 = cos_pwr1**2
         sin_pwr1 = sin(angleEdge(iEdge))
         sin_pwr2 = sin_pwr1**2
         cossin = cos_pwr1*sin_pwr1

         ! change later:
         !do k=1,maxLevelEdgeBot(iEdge)
         do k=1,nVertLevels

            ! strain rate tensor at cell center
            eps11 = normalVelocity(k,iEdge)*cos_pwr2 - tangentialVelocity(k,iEdge)*cossin
            eps22 = normalVelocity(k,iEdge)*sin_pwr2 + tangentialVelocity(k,iEdge)*cossin
            eps12 = normalVelocity(k,iEdge)*cossin   + tangentialVelocity(k,iEdge)*0.5*(cos_pwr2-sin_pwr2)

            ! index 1, 2, and 3 is for 11, 22, and 12 
            strainRate2DCell(1,k,cell1) = strainRate2DCell(1,k,cell1) + eps11*invAreaCell1 * dvEdge(iEdge)
            strainRate2DCell(1,k,cell2) = strainRate2DCell(1,k,cell2) - eps11*invAreaCell2 * dvEdge(iEdge)
            strainRate2DCell(2,k,cell1) = strainRate2DCell(2,k,cell1) + eps22*invAreaCell1 * dvEdge(iEdge)
            strainRate2DCell(2,k,cell2) = strainRate2DCell(2,k,cell2) - eps22*invAreaCell2 * dvEdge(iEdge)
            strainRate2DCell(3,k,cell1) = strainRate2DCell(3,k,cell1) + eps12*invAreaCell1 * dvEdge(iEdge)
            strainRate2DCell(3,k,cell2) = strainRate2DCell(3,k,cell2) - eps12*invAreaCell2 * dvEdge(iEdge)

            ! strain rate tensor at vertex
            eps11 = -tangentialVelocity(k,iEdge)*sin_pwr2   + normalVelocity(k,iEdge)*cossin
            eps22 = -tangentialVelocity(k,iEdge)*cos_pwr2   - normalVelocity(k,iEdge)*cossin
            eps12 =  tangentialVelocity(k,iEdge)*cossin - normalVelocity(k,iEdge)*0.5*(cos_pwr2-sin_pwr2)

            strainRate2DVertex(1,k,vertex1) = strainRate2DVertex(1,k,vertex1) - eps11*invAreaTri1* dcEdge(iEdge)
            strainRate2DVertex(1,k,vertex2) = strainRate2DVertex(1,k,vertex2) + eps11*invAreaTri2* dcEdge(iEdge)
            strainRate2DVertex(2,k,vertex1) = strainRate2DVertex(2,k,vertex1) - eps22*invAreaTri1* dcEdge(iEdge)
            strainRate2DVertex(2,k,vertex2) = strainRate2DVertex(2,k,vertex2) + eps22*invAreaTri2* dcEdge(iEdge)
            strainRate2DVertex(3,k,vertex1) = strainRate2DVertex(3,k,vertex1) - eps12*invAreaTri1* dcEdge(iEdge)
            strainRate2DVertex(3,k,vertex2) = strainRate2DVertex(3,k,vertex2) + eps12*invAreaTri2* dcEdge(iEdge)

         end do
      end do

   end subroutine mpas_strain_rate_LonLat!}}}

!***********************************************************************
!
!  routine mpas_div_tensor_LonLat_strong
!
!> \brief   Computes divergence of the stress tensor
!> \author  Mark Petersen
!> \date    25 September 2012
!> \version SVN:$Id$
!> \details 
!>  This routine computes the divergence of the stress tensor
!
!-----------------------------------------------------------------------

   subroutine mpas_div_tensor_LonLat_strong(grid, tensorCell, tensorVertex, divTensor)!{{{

      !-----------------------------------------------------------------
      !
      ! input variables
      !
      !-----------------------------------------------------------------

      real (kind=RKIND), dimension(:,:,:), intent(in) :: &
         tensorCell  !< Input: tensor at cell center
      real (kind=RKIND), dimension(:,:,:), intent(in) :: &
         tensorVertex  !< Input: tensor at vertex

      type (mesh_type), intent(in) :: &
         grid          !< Input: grid information

      !-----------------------------------------------------------------
      !
      ! input/output variables
      !
      !-----------------------------------------------------------------

      !-----------------------------------------------------------------
      !
      ! output variables
      !
      !-----------------------------------------------------------------

      real (kind=RKIND), dimension(:,:), intent(out) :: &
         divTensor  !< Output: normal component of divergence of the stress tensor at edge

      !-----------------------------------------------------------------
      !
      ! local variables
      !
      !-----------------------------------------------------------------

      integer :: iEdge, nEdgesSolve, cell1, cell2, vertex1, vertex2, k

      integer, dimension(:), pointer :: maxLevelEdgeTop
      integer, dimension(:,:), pointer :: cellsOnEdge, verticesOnEdge, edgeMask

      real (kind=RKIND) :: invAreaCell1, invAreaCell2, invAreaTri1, invAreaTri2, &
        cos_pwr1, sin_pwr1, cos_pwr2, sin_pwr2, cossin, uDvEdge, uDcEdge, eps11, eps22, eps12, &
        invdcEdge, invdvEdge
      real (kind=RKIND), dimension(:), pointer :: dvEdge, dcEdge, areaCell, areaTriangle, angleEdge

      !-----------------------------------------------------------------
      !
      ! call relevant routines for computing tendencies
      ! note that the user can choose multiple options and the 
      !   tendencies will be added together
      !
      !-----------------------------------------------------------------

      nEdgesSolve = grid % nEdgesSolve

      maxLevelEdgeTop   => grid % maxLevelEdgeTop % array
      cellsOnEdge => grid % cellsOnEdge % array
      verticesOnEdge    => grid % verticesOnEdge % array
      dcEdge            => grid % dcEdge % array
      dvEdge            => grid % dvEdge % array
      angleEdge         => grid % angleEdge % array
      edgeMask => grid % edgeMask % array

      do iEdge=1,nEdgesSolve
         vertex1 = verticesOnEdge(1,iEdge)
         vertex2 = verticesOnEdge(2,iEdge)

         cell1 = cellsOnEdge(1,iEdge)
         cell2 = cellsOnEdge(2,iEdge)

         cos_pwr1 = cos(angleEdge(iEdge))
         cos_pwr2 = cos_pwr1**2
         sin_pwr1 = sin(angleEdge(iEdge))
         sin_pwr2 = sin_pwr1**2
         cossin = cos_pwr1*sin_pwr1

         invdcEdge = 1.0 / dcEdge(iEdge)
         invdvEdge = 1.0 / dvEdge(iEdge)

         do k=1,maxLevelEdgeTop(iEdge)
            divTensor(k,iEdge) = edgeMask(k,iEdge) * invdcEdge &
               * (  cos_pwr2*tensorCell(1,k,cell2) - 2.0*cossin*tensorCell(3,k,cell2) + sin_pwr2*tensorCell(2,k,cell2) &
                  -(cos_pwr2*tensorCell(1,k,cell1) - 2.0*cossin*tensorCell(3,k,cell1) + sin_pwr2*tensorCell(2,k,cell1)) ) &
               + edgeMask(k,iEdge) * invdvEdge &
               * (  (cos_pwr2-sin_pwr2)*tensorVertex(3,k,vertex2) + cossin*(tensorVertex(1,k,vertex2) - tensorVertex(2,k,vertex2)) &
                  -((cos_pwr2-sin_pwr2)*tensorVertex(3,k,vertex1) + cossin*(tensorVertex(1,k,vertex1) - tensorVertex(2,k,vertex1))))
         end do

      end do

   end subroutine mpas_div_tensor_LonLat_strong!}}}

!***********************************************************************
!
!  routine mpas_test_tensor
!
!> \brief   Tests strain rate and tensor divergence operators
!> \author  Mark Petersen
!> \date    17 April 2013
!> \details 
!>  This routine tests strain rate and tensor divergence operators.
!
!-----------------------------------------------------------------------

   subroutine mpas_test_tensor(domain) !{{{

      !-----------------------------------------------------------------
      !
      ! input variables
      !
      !-----------------------------------------------------------------

      !-----------------------------------------------------------------
      !
      ! input/output variables
      !
      !-----------------------------------------------------------------

      type (domain_type), intent(inout) :: domain

      !-----------------------------------------------------------------
      !
      ! output variables
      !
      !-----------------------------------------------------------------

      !-----------------------------------------------------------------
      !
      ! local variables
      !
      !-----------------------------------------------------------------

      type (block_type), pointer :: block

      integer :: nCells, nEdges, nVertices, nVertLevels, iCell, iEdge, k, i, p, strainRateLonLatRIndex

      real (kind=RKIND) :: xVelocity, yVelocity, cn, cs, r, theta, rot, f, g1, g2, fcos, pi2l, ld, &
        divSigma_x, divSigma_y, kLon, kLat, &
        lon, lat, sin_kLon_lon, cos_kLon_lon, sin_kLat_lat, cos_kLat_lat, sin_lat, sec_lat, tan_lat, &
        velocityZonal, velocityMeridional, rotAngle
      real (kind=RKIND), dimension(6) :: strainRateLonLatCellSolution
      real (kind=RKIND), dimension(:), pointer :: angleEdge, xCell, yCell, xEdge, yEdge, latCell, lonCell, latEdge, lonEdge
      real (kind=RKIND), dimension(:,:), pointer :: normalVelocity, tangentialVelocity
      real (kind=RKIND), dimension(:,:), pointer :: edgeNormalVectors, edgeTangentVectors
      real (kind=RKIND), dimension(:,:,:), pointer :: strainRateR3Cell, strainRateR3Edge, divTensorR3Cell, divTensorLonLatRCell, divTensorLonLatRCellSolution, strainRate2DCell, strainRate2DVertex

      real (kind=RKIND), dimension(:,:,:), pointer :: strainRateR3CellSolution, strainRate2DCellSolution, divTensorR3CellSolution, strainRateLonLatRCell, strainRateLonLatREdge, strainRateLonLatRCellSolution
      real (kind=RKIND), dimension(:,:,:), pointer :: strainRateLonLatRCellDiff, divTensorLonLatRCellDiff, outerProductEdge
      character(len=16) :: test_function_type
      logical :: computeStrainRate

    ! Initialize z-level grid variables from h, read in from input file.
    block => domain % blocklist
    do while (associated(block))

      nCells      = block % mesh % nCells
      nEdges      = block % mesh % nEdges
      nVertices   = block % mesh % nVertices
      nVertLevels = block % mesh % nVertLevels

      xCell  => block % mesh % xCell % array
      yCell  => block % mesh % yCell % array
      latCell=> block % mesh % latCell % array
      lonCell=> block % mesh % lonCell % array
      latEdge=> block % mesh % latEdge % array
      lonEdge=> block % mesh % lonEdge % array
      xEdge  => block % mesh % xEdge % array
      yEdge  => block % mesh % yEdge % array
      angleEdge => block % mesh % angleEdge % array

      edgeNormalVectors  => block % mesh % edgeNormalVectors % array
      edgeTangentVectors => block % mesh % edgeTangentVectors % array


      normalVelocity      => block % state % time_levs(1) % state % normalVelocity % array
      tangentialVelocity  => block % state % time_levs(1) % state % tangentialVelocity % array

      ! mrp convert these to scratch so they are not required for other cores
      strainRate2DCell    => block % state % time_levs(1) % state % strainRate2DCell % array
      strainRate2DVertex    => block % state % time_levs(1) % state % strainRate2DVertex % array
      strainRateR3Cell    => block % state % time_levs(1) % state % strainRateR3Cell % array
      strainRateR3Edge    => block % state % time_levs(1) % state % strainRateR3Edge % array
      divTensorR3Cell     => block % state % time_levs(1) % state % divTensorR3Cell % array
      divTensorLonLatRCell     => block % state % time_levs(1) % state % divTensorLonLatRCell % array
      divTensorLonLatRCellSolution     => block % state % time_levs(1) % state % divTensorLonLatRCellSolution % array
      outerProductEdge    => block % state % time_levs(1) % state % outerProductEdge % array

      strainRate2DCellSolution => block % state % time_levs(1) % state % strainRate2DCellSolution % array
      strainRateLonLatREdge => block % state % time_levs(1) % state % strainRateLonLatREdge % array
      strainRateLonLatRCell => block % state % time_levs(1) % state % strainRateLonLatRCell % array
      strainRateLonLatRCellSolution => block % state % time_levs(1) % state % strainRateLonLatRCellSolution % array
      strainRateR3CellSolution => block % state % time_levs(1) % state % strainRateR3CellSolution % array
      divTensorR3CellSolution => block % state % time_levs(1) % state % divTensorR3CellSolution % array
      strainRateLonLatRCellDiff => block % state % time_levs(1) % state % strainRateLonLatRCellDiff % array
      divTensorLonLatRCellDiff => block % state % time_levs(1) % state % divTensorLonLatRCellDiff % array

      ! create test functions for normalVelocity and tangentialVelocity
      normalVelocity = 0.0
      tangentialVelocity = 0.0
      strainRateR3CellSolution = 0.0
      divTensorR3CellSolution = 0.0

      cn = 15.0e4
      cs = 20.0e4
      rot = 1.0 !pii/4.0 !0.0*pii/2
      p = 2 ! power for polynomial function

      ld = 100.0e3  ! wavelength in meters
      pi2l = pii/ld
      g1 = cn*cos(rot) - cs*sin(rot)
      g2 = cn*sin(rot) + cs*cos(rot)

      kLon = 0.0
      kLat = 0.0

      R = block % mesh % sphere_radius
      computeStrainRate = .true.

     if (config_tensor_test_function.eq.'constant') then
       ! linear function in x
        do iEdge = 1,nEdges
           xVelocity = cn
           yVelocity = cs
           normalVelocity(:,iEdge) = xVelocity*edgeNormalVectors(1,iEdge) + yVelocity*edgeNormalVectors(2,iEdge)
           tangentialVelocity(:,iEdge) = xVelocity*edgeTangentVectors(1,iEdge) + yVelocity*edgeTangentVectors(2,iEdge)
        enddo

        strainRateR3CellSolution = 0.0
        divTensorR3CellSolution = 0.0

     elseif (config_tensor_test_function.eq.'linear_x') then
       ! linear function in x
        do iEdge = 1,nEdges
           xVelocity = cn*xEdge(iEdge)
           yVelocity = cs*xEdge(iEdge)
           normalVelocity(:,iEdge) = xVelocity*edgeNormalVectors(1,iEdge) + yVelocity*edgeNormalVectors(2,iEdge)
           tangentialVelocity(:,iEdge) = xVelocity*edgeTangentVectors(1,iEdge) + yVelocity*edgeTangentVectors(2,iEdge)
        enddo

        strainRateR3CellSolution(1,:,:) = cn
        strainRateR3CellSolution(2,:,:) = 0.0
        strainRateR3CellSolution(4,:,:) = 0.5*cs

        divTensorR3CellSolution = 0.0

     elseif (config_tensor_test_function.eq.'linear_y') then

        ! linear function in y
        do iEdge = 1,nEdges
          xVelocity = -cs*yEdge(iEdge)
          yVelocity =  cn*yEdge(iEdge)
          normalVelocity(:,iEdge) = xVelocity*edgeNormalVectors(1,iEdge) + yVelocity*edgeNormalVectors(2,iEdge)
          tangentialVelocity(:,iEdge) = xVelocity*edgeTangentVectors(1,iEdge) + yVelocity*edgeTangentVectors(2,iEdge)
        enddo

        strainRateR3CellSolution(1,:,:) = 0.0
        strainRateR3CellSolution(2,:,:) = cn
        strainRateR3CellSolution(4,:,:) = -0.5*cs

        divTensorR3CellSolution = 0.0

     elseif (config_tensor_test_function.eq.'linear_arb_rot') then

        ! linear function, arbitrary rotation

        do iEdge = 1,nEdges
           ! arbitrary rotation
           r = sqrt(xEdge(iEdge)**2 + yEdge(iEdge)**2)
           theta = atan(yEdge(iEdge)/xEdge(iEdge))

           f = r*cos(theta-rot)
           xVelocity = f*g1
           yVelocity = f*g2

           normalVelocity(:,iEdge) = xVelocity*edgeNormalVectors(1,iEdge) + yVelocity*edgeNormalVectors(2,iEdge)
           tangentialVelocity(:,iEdge) = xVelocity*edgeTangentVectors(1,iEdge) + yVelocity*edgeTangentVectors(2,iEdge)

        enddo

        strainRateR3CellSolution(1,:,:) = cos(rot)*g1
        strainRateR3CellSolution(2,:,:) = sin(rot)*g2
        strainRateR3CellSolution(4,:,:) = 0.5*(cos(rot)*g2 + sin(rot)*g1)

        divTensorR3CellSolution = 0.0

     elseif (config_tensor_test_function.eq.'power_x') then

       ! power function in x: x^p
        do iEdge = 1,nEdges
           xVelocity = cn*xEdge(iEdge)**p
           yVelocity = cs*xEdge(iEdge)**p
           normalVelocity(:,iEdge) = xVelocity*edgeNormalVectors(1,iEdge) + yVelocity*edgeNormalVectors(2,iEdge)
           tangentialVelocity(:,iEdge) = xVelocity*edgeTangentVectors(1,iEdge) + yVelocity*edgeTangentVectors(2,iEdge)
        enddo

        do iCell = 1,nCells
           strainRateR3CellSolution(1,:,iCell) = cn    *p*xCell(iCell)**(p-1)
           strainRateR3CellSolution(2,:,iCell) = 0.0
           strainRateR3CellSolution(4,:,iCell) = 0.5*cs*p*xCell(iCell)**(p-1)

           divTensorR3CellSolution(1,:,iCell) = cn    *p*(p-1)*xCell(iCell)**(p-2)
           divTensorR3CellSolution(2,:,iCell) = 0.5*cs*p*(p-1)*xCell(iCell)**(p-2)  
        end do

     elseif (config_tensor_test_function.eq.'power_y') then

        ! power function in y: y^n
        do iEdge = 1,nEdges
           xVelocity = -cs*yEdge(iEdge)**p
           yVelocity =  cn*yEdge(iEdge)**p
           normalVelocity(:,iEdge) = xVelocity*edgeNormalVectors(1,iEdge) + yVelocity*edgeNormalVectors(2,iEdge)
           tangentialVelocity(:,iEdge) = xVelocity*edgeTangentVectors(1,iEdge) + yVelocity*edgeTangentVectors(2,iEdge)
        enddo

        do iCell = 1,nCells
           strainRateR3CellSolution(1,:,iCell) = 0.0
           strainRateR3CellSolution(2,:,iCell) =  cn    *p*yCell(iCell)**(p-1)
           strainRateR3CellSolution(4,:,iCell) = -0.5*cs*p*yCell(iCell)**(p-1)

           divTensorR3CellSolution(1,:,iCell) = -0.5*cs*p*(p-1)*yCell(iCell)**(p-2)  
           divTensorR3CellSolution(2,:,iCell) =  cn    *p*(p-1)*yCell(iCell)**(p-2)
        end do

     elseif (config_tensor_test_function.eq.'power_arb_rot') then

        ! power function, arbitrary rotation

        do iEdge = 1,nEdges
           ! arbitrary rotation
           r = sqrt(xEdge(iEdge)**2 + yEdge(iEdge)**2)
           theta = atan(yEdge(iEdge)/xEdge(iEdge))
           f = r*cos(theta-rot)

           xVelocity = g1*f**p
           yVelocity = g2*f**p
           normalVelocity(:,iEdge) = xVelocity*edgeNormalVectors(1,iEdge) + yVelocity*edgeNormalVectors(2,iEdge)
           tangentialVelocity(:,iEdge) = xVelocity*edgeTangentVectors(1,iEdge) + yVelocity*edgeTangentVectors(2,iEdge)
        enddo

        do iCell = 1,nCells
           r = sqrt(xCell(iCell)**2 + yCell(iCell)**2)
           theta = atan(yCell(iCell)/xCell(iCell))
           f = r*cos(theta-rot)

           strainRateR3CellSolution(1,:,iCell) = p *f**(p-1) *cos(rot)*g1
           strainRateR3CellSolution(2,:,iCell) = p *f**(p-1) *sin(rot)*g2
           strainRateR3CellSolution(4,:,iCell) = p *f**(p-1) *(cos(rot)*g2+sin(rot)*g1)/2.0

           divTensorR3CellSolution(1,:,iCell) = p*(p-1)*f**(p-2) *(cos(rot)**2*g1 + 0.5*(sin(rot)**2*g1 + sin(rot)*cos(rot)*g2) )
           divTensorR3CellSolution(2,:,iCell) = p*(p-1)*f**(p-2) *(sin(rot)**2*g2 + 0.5*(cos(rot)**2*g2 + sin(rot)*cos(rot)*g1) )
        end do

     elseif (config_tensor_test_function.eq.'sin_arb_rot') then

        ! sin function, arbitrary rotation

        do iEdge = 1,nEdges
           ! arbitrary rotation
           r = sqrt(xEdge(iEdge)**2 + yEdge(iEdge)**2)
           theta = atan(yEdge(iEdge)/xEdge(iEdge))
           f = sin(pi2l*r*cos(theta-rot))

           xVelocity = f*g1
           yVelocity = f*g2
           normalVelocity(:,iEdge) = xVelocity*edgeNormalVectors(1,iEdge) + yVelocity*edgeNormalVectors(2,iEdge)
           tangentialVelocity(:,iEdge) = xVelocity*edgeTangentVectors(1,iEdge) + yVelocity*edgeTangentVectors(2,iEdge)
        enddo

        do iCell = 1,nCells
           r = sqrt(xCell(iCell)**2 + yCell(iCell)**2)
           theta = atan(yCell(iCell)/xCell(iCell))
           f = sin(pi2l*r*cos(theta-rot))
           fcos = cos(pi2l*r*cos(theta-rot))

           strainRateR3CellSolution(1,:,iCell) = pi2l*fcos*cos(rot)*g1
           strainRateR3CellSolution(2,:,iCell) = pi2l*fcos*sin(rot)*g2
           strainRateR3CellSolution(4,:,iCell) = pi2l*fcos*(cos(rot)*g2+sin(rot)*g1)/2.0

           divTensorR3CellSolution(1,:,iCell) = -pi2l**2*f*(cos(rot)**2*g1 + 0.5*(sin(rot)**2*g1 + sin(rot)*cos(rot)*g2) )
           divTensorR3CellSolution(2,:,iCell) = -pi2l**2*f*(sin(rot)**2*g2 + 0.5*(cos(rot)**2*g2 + sin(rot)*cos(rot)*g1) )
        end do

     elseif (config_tensor_test_function.eq.'spherical_solid') then

        do iEdge = 1,nEdges
           lon = lonEdge(iEdge)
           lat = latEdge(iEdge)

           velocityZonal      = cos(lat)
           velocityMeridional = 0.0
           normalVelocity(:,iEdge) = velocityZonal*cos(angleEdge(iEdge)) + velocityMeridional*sin(angleEdge(iEdge))
           tangentialVelocity(:,iEdge) = -velocityZonal*sin(angleEdge(iEdge)) + velocityMeridional*cos(angleEdge(iEdge))
        enddo

        do iCell = 1,nCells

           lon = lonCell(iCell)
           lat = latCell(iCell)

           block % state % time_levs(1) % state % streamFunctionCell     % array(:,iCell) = 0.0 ! actually -lat/2 - sin(lat)**2/4
           block % state % time_levs(1) % state % zonalVelocityCell      % array(:,iCell) = cos(lat)
           block % state % time_levs(1) % state % meridionalVelocityCell % array(:,iCell) = 0.0

           strainRateLonLatRCellSolution(1,1,iCell) = & ! Elonlon
                 0.0
           strainRateLonLatRCellSolution(2,1,iCell) = & ! Elatlat
                 0.0
           strainRateLonLatRCellSolution(3,1,iCell) = & ! Err
                 0.0
           strainRateLonLatRCellSolution(4,1,iCell) = & ! Elonlat
                 0.0
           strainRateLonLatRCellSolution(5,1,iCell) = & ! Elatr
                 0.0
           strainRateLonLatRCellSolution(6,1,iCell) = & ! Elonr
                 - 3.0/R/2.0*cos(lat) 

           call mpas_tensor_LonLatR_to_R3(strainRateLonLatRCellSolution(:,1,iCell), strainRateR3CellSolution(:,1,iCell), lon, lat)
        enddo

        divTensorR3CellSolution = 0.0

     elseif (config_tensor_test_function.eq.'sph_Williamson') then

        rotAngle=pii/4

        do iEdge = 1,nEdges
           lon = lonEdge(iEdge)
           lat = latEdge(iEdge)

           velocityZonal      =  cos(lat)*cos(rotAngle) + sin(lat)*cos(lon)*sin(rotAngle)
           velocityMeridional = -sin(lat)*sin(rotAngle)

           normalVelocity(:,iEdge) = velocityZonal*cos(angleEdge(iEdge)) + velocityMeridional*sin(angleEdge(iEdge))
           tangentialVelocity(:,iEdge) = -velocityZonal*sin(angleEdge(iEdge)) + velocityMeridional*cos(angleEdge(iEdge))
        enddo

        do iCell = 1,nCells

           lon = lonCell(iCell)
           lat = latCell(iCell)

           strainRateLonLatRCellSolution(1,1,iCell) = & ! Elonlon
                 1/R/cos(lat)*( sin(rotAngle)*sin(lat)**2 - sin(rotAngle)*sin(lat)*sin(lon))
           strainRateLonLatRCellSolution(2,1,iCell) = & ! Elatlat
                 -1/R*cos(lat)*sin(rotAngle)
           strainRateLonLatRCellSolution(3,1,iCell) = & ! Err
                 0.0
           strainRateLonLatRCellSolution(4,1,iCell) = & ! Elonlat
                 1/2.0/R*(  cos(lat)*cos(lon)*sin(rotAngle) - cos(rotAngle)*sin(lat) + tan(lat)*cos(rotAngle)*cos(lat) + tan(lat)*cos(lon)*sin(rotAngle)*sin(lat))
           strainRateLonLatRCellSolution(5,1,iCell) = & ! Elatr
                 3.0/R/2.0*sin(lat)*sin(rotAngle)
           strainRateLonLatRCellSolution(6,1,iCell) = & ! Elonr
                 - 3.0/R/2.0*( cos(lat)*cos(rotAngle) + cos(lon)*sin(rotAngle)*sin(lat))

           call mpas_tensor_LonLatR_to_R3(strainRateLonLatRCellSolution(:,1,iCell), strainRateR3CellSolution(:,1,iCell), lon, lat)

        end do

     elseif (config_tensor_test_function.eq.'sph_uCosCos') then

        do iEdge = 1,nEdges
           lon = lonEdge(iEdge)
           lat = latEdge(iEdge)

           velocityZonal      = cos(lon)*(1+cos(2*lat))
           velocityMeridional = 0.0

           normalVelocity(:,iEdge) = velocityZonal*cos(angleEdge(iEdge)) + velocityMeridional*sin(angleEdge(iEdge))
           tangentialVelocity(:,iEdge) = -velocityZonal*sin(angleEdge(iEdge)) + velocityMeridional*cos(angleEdge(iEdge))
        enddo

        do iCell = 1,nCells

           lon = lonCell(iCell)
           lat = latCell(iCell)

           strainRateLonLatRCellSolution(1,1,iCell) = & ! Elonlon
                 -1/R*(1+cos(2*lat))*sin(lon)/cos(lat)
           strainRateLonLatRCellSolution(2,1,iCell) = & ! Elatlat
                 0.0
           strainRateLonLatRCellSolution(3,1,iCell) = & ! Err
                 0.0
           strainRateLonLatRCellSolution(4,1,iCell) = & ! Elonlat
                 1/2.0/R*( -2*cos(lon)*sin(2*lat) + (1+cos(2*lat))*cos(lon)*tan(lat))
           strainRateLonLatRCellSolution(5,1,iCell) = & ! Elatr
                 0.0
           strainRateLonLatRCellSolution(6,1,iCell) = & ! Elonr
                 - 3.0/R/2.0*(1+cos(2*lat))*cos(lon)

           call mpas_tensor_LonLatR_to_R3(strainRateLonLatRCellSolution(:,1,iCell), strainRateR3CellSolution(:,1,iCell), lon, lat)

        end do

     elseif (config_tensor_test_function.eq.'sph_vCosCos') then

        do iEdge = 1,nEdges
           lon = lonEdge(iEdge)
           lat = latEdge(iEdge)

           velocityZonal      = 0.0
           velocityMeridional = cos(lon)*(1+cos(2*lat))

           normalVelocity(:,iEdge) = velocityZonal*cos(angleEdge(iEdge)) + velocityMeridional*sin(angleEdge(iEdge))
           tangentialVelocity(:,iEdge) = -velocityZonal*sin(angleEdge(iEdge)) + velocityMeridional*cos(angleEdge(iEdge))
        enddo

        do iCell = 1,nCells

           lon = lonCell(iCell)
           lat = latCell(iCell)

           strainRateLonLatRCellSolution(1,1,iCell) = & ! Elonlon
                 -1/R*(1+cos(2*lat))*cos(lon)*tan(lat)
           strainRateLonLatRCellSolution(2,1,iCell) = & ! Elatlat
                 -2/R*cos(lon)*sin(2*lat)
           strainRateLonLatRCellSolution(3,1,iCell) = & ! Err
                 0.0
           strainRateLonLatRCellSolution(4,1,iCell) = & ! Elonlat
                 -1/2.0/R*(1+cos(2*lat))*sin(lon)/cos(lat)
           strainRateLonLatRCellSolution(5,1,iCell) = & ! Elatr
                 - 3.0/R/2.0*(1+cos(2*lat))*cos(lon)
           strainRateLonLatRCellSolution(6,1,iCell) = & ! Elonr
                 0.0

           call mpas_tensor_LonLatR_to_R3(strainRateLonLatRCellSolution(:,1,iCell), strainRateR3CellSolution(:,1,iCell), lon, lat)

        end do

     elseif (config_tensor_test_function.eq.'sph_ELonLon_CosCos') then
        computeStrainRate = .false.
        strainRateLonLatRIndex = 1

        strainRateLonLatREdge = 0.0
        do iEdge = 1,nEdges
           lon = lonEdge(iEdge)
           lat = latEdge(iEdge)
           strainRateLonLatREdge(strainRateLonLatRIndex,1,iEdge) = cos(lon)*(1+cos(2*lat))
           call mpas_tensor_LonLatR_to_R3(strainRateLonLatREdge(:,1,iEdge), strainRateR3Edge(:,1,iEdge), lon, lat)
        enddo

        strainRateLonLatRCell = 0.0
        do iCell = 1,nCells
           lon = lonCell(iCell)
           lat = latCell(iCell)

           divTensorLonLatRCellSolution(1,:,iCell) = -1/R*(1+cos(2*lat))*sin(lon)/cos(lat)
           divTensorLonLatRCellSolution(2,:,iCell) =  1/R*(1+cos(2*lat))*cos(lon)*tan(lat)
           divTensorLonLatRCellSolution(3,:,iCell) = -1/R*(1+cos(2*lat))*cos(lon)

        end do

     elseif (config_tensor_test_function.eq.'sph_ELatLat_CosCos') then
        computeStrainRate = .false.
        strainRateLonLatRIndex = 2

        strainRateLonLatREdge = 0.0
        do iEdge = 1,nEdges
           lon = lonEdge(iEdge)
           lat = latEdge(iEdge)
           strainRateLonLatREdge(strainRateLonLatRIndex,1,iEdge) = cos(lon)*(1+cos(2*lat))
           call mpas_tensor_LonLatR_to_R3(strainRateLonLatREdge(:,1,iEdge), strainRateR3Edge(:,1,iEdge), lon, lat)
        enddo

        strainRateLonLatRCell = 0.0
        do iCell = 1,nCells
           lon = lonCell(iCell)
           lat = latCell(iCell)

           divTensorLonLatRCellSolution(1,:,iCell) =  0.0
           divTensorLonLatRCellSolution(2,:,iCell) = -2/R*cos(lon)*sin(2*lat) -1/R*(1+cos(2*lat))*cos(lon)*tan(lat)
           divTensorLonLatRCellSolution(3,:,iCell) = -1/R*(1+cos(2*lat))*cos(lon)

        end do

     elseif (config_tensor_test_function.eq.'sph_ELonLat_CosCos') then
        computeStrainRate = .false.
        strainRateLonLatRIndex = 4

        strainRateLonLatREdge = 0.0
        do iEdge = 1,nEdges
           lon = lonEdge(iEdge)
           lat = latEdge(iEdge)
           strainRateLonLatREdge(strainRateLonLatRIndex,1,iEdge) = cos(lon)*(1+cos(2*lat))
           call mpas_tensor_LonLatR_to_R3(strainRateLonLatREdge(:,1,iEdge), strainRateR3Edge(:,1,iEdge), lon, lat)
        enddo

        strainRateLonLatRCell = 0.0
        do iCell = 1,nCells
           lon = lonCell(iCell)
           lat = latCell(iCell)

           divTensorLonLatRCellSolution(1,:,iCell) = -2/R*cos(lon)*sin(2*lat) -2/R*(1+cos(2*lat))*cos(lon)*tan(lat)
           divTensorLonLatRCellSolution(2,:,iCell) = -1/R*(1+cos(2*lat))*sin(lon)/cos(lat)
           divTensorLonLatRCellSolution(3,:,iCell) =  0.0

        end do

     else
       print *, 'bad choice of config_tensor_test_function:',config_tensor_test_function
       stop
     endif


     if (computeStrainRate) then
        call mpas_strain_rate_R3(block % mesh, normalVelocity, tangentialVelocity, strainRateR3Cell, outerProductEdge)

        call mpas_matrix_cell_to_edge(block % mesh, strainRateR3Cell, strainRateR3Edge)
     endif

     call mpas_divergence_of_tensor_3D(block % mesh, strainRateR3Edge, divTensorR3Cell)

     do iCell = 1,nCells

        call mpas_tensor_R3_to_LonLatR(strainRateR3Cell(:,1,iCell), strainRateLonLatRCell(:,1,iCell), lonCell(iCell), latCell(iCell))

        call mpas_vector_R3_to_LonLatR(divTensorR3Cell(:,1,iCell), divTensorLonLatRCell(:,1,iCell), lonCell(iCell), latCell(iCell))

        call mpas_vector_LonLatR_to_R3(divTensorLonLatRCellSolution(:,1,iCell),  divTensorR3CellSolution(:,1,iCell), lonCell(iCell), latCell(iCell))

     enddo

    ! test 2D operations:
    call mpas_strain_rate_LonLat(block % mesh, normalVelocity,tangentialVelocity, strainRate2DCell, strainRate2DVertex)

      strainRateLonLatRCellDiff = strainRateLonLatRCell- strainRateLonLatRCellSolution
      divTensorLonLatRCellDiff  = divTensorLonLatRCell- divTensorLonLatRCellSolution

        block => block % next
      end do

   end subroutine mpas_test_tensor!}}}

!***********************************************************************
!
!  routine mpas_tensor_operations_init
!
!> \brief   Initializes flags used within tendency routines.
!> \author  Mark Petersen
!> \date    17 April 2013
!> \details 
!>  This routine initializes flags related to quantities computed within
!>  other tendency routines.
!
!-----------------------------------------------------------------------
!    subroutine mpas_tensor_operations_init(err)!{{{
!        integer, intent(out) :: err !< Output: Error flag

!    end subroutine mpas_tensor_operations_init!}}}

!***********************************************************************




end module mpas_tensor_operations


!|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
! vim: foldmethod=marker

