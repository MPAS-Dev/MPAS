<?xml version="1.0"?>
<registry model="mpas" core="landice" core_abbrev="li" version="4.0">


<!-- ======================================================================= -->
<!-- MODEL DIMENSIONS -->

	<dims>
		<dim name="nCells" units="unitless"
		     description="The number of polygons in the primary grid."
		/>
		<dim name="nEdges" units="unitless"
		     description="The number of edge midpoints in either the primary or dual grid."
		/>
		<dim name="maxEdges" units="unitless"
		     description="The largest number of edges any polygon within the grid has."
		/>
		<dim name="maxEdges2" units="unitless"
		     description="Two times the largest number of edges any polygon within the grid has."
		/>
		<dim name="nVertices" units="unitless"
		     description="The total number of cells in the dual grid. Also the number of corners in the primary grid."
		/>
		<dim name="ONE" definition="1" units="unitless"
		     description="The number one as a dimension."
		/>
		<dim name="TWO" definition="2" units="unitless"
		     description="The number two as a dimension."
		/>
		<dim name="R3" definition="3" units="unitless"
		     description="The number three as a dimension."
		/>
		<dim name="vertexDegree" units="unitless"
		     description="The number of cells or edges touching each vertex."
		/>
		<dim name="nVertLevels" units="unitless"
		     description="The number of levels in the vertical direction. All vertical levels share the same horizontal locations."
		/>
		<dim name="nVertInterfaces" definition="nVertLevels+1" units="unitless"
		     description="The number of interfaces in the vertical direction."
		/>
	</dims>


<!-- ======================================================================= -->
<!-- NAMELIST RECORDS -->

	<nml_record name="velocity_solver" in_defaults="true">
		<nml_option name="config_velocity_solver" type="character" default_value="sia" units="unitless"
		            description="Selection of the method for solving ice velocity. 'L1L2', 'FO', and 'Stokes' require compiling with external dycores. 'none' skips the calculation of velocity so the velocity field will be 0 or set to a field read from an input file."
		            possible_values="'sia', 'L1L2', 'FO', 'Stokes', 'none'"
		/>
		<nml_option name="config_sia_tangent_slope_calculation" type="character" default_value="from_vertex_barycentric" units="unitless"
		            description="Selection of the method for calculating the tangent component of surface slope at edges needed by the SIA velocity solver.
'from_vertex_barycentric' interpolates upperSurface values from cell centers to vertices using the barycentric interpolation routine in operators (mpas_cells_to_points_using_baryweights) and then calculates the slope between vertices.  It works for obtuse triangles, but will not work correctly across the edges of periodic meshes.
'from_vertex_barycentric_kiteareas' interpolates upperSurface values from cell centers to vertices using barycentric interpolation based on kiterea values and then calculates the slope between vertices.  It will work across the edges of periodic meshes, but will not work correctly for obtuse triangles.
'from_normal_slope' uses the vector operator mpas_tangential_vector_1d to calculate the tangent slopes from the normal slopes on the edges of the adjacent cells.  It will work for any mesh configuration, but is the least accurate method."
		            possible_values="'from_vertex_barycentric', 'from_vertex_barycentric_kiteareas', 'from_normal_slope'"
		/>
		<nml_option name="config_flowParamA_calculation" type="character" default_value="constant" units="unitless"
			description="Selection of the method for calculating the flow law parameter A.  If 'constant' is selected, the value is set to config_default_flowParamA.  The other options are calculated from the temperature field."
			possible_values="'constant', 'PB1982', 'CP2010'"
		/>
		<nml_option name="config_do_velocity_reconstruction_for_external_dycore" type="logical" default_value=".false." units="unitless"
		            description="By default, external, higher-order dycores return the uReconstructX and uReconstructY fields (which are the native locations of their FEM solution).  If this option is set to .true., uReconstructX and uReconstructY will be calculated by MPAS using framework's vector reconstruction routines based on the values of normalVelocity supplied by the external dycore.  This provides a way to test the calculation of normalVelocity in the interface."
		            possible_values=".true. or .false."
		/>
	</nml_record>


	<nml_record name="advection" in_defaults="true">
		<nml_option name="config_thickness_advection" type="character" default_value="fo" units="unitless"
		            description="Selection of the method for advecting thickness."
		            possible_values="'fo', 'none'"
		/>
		<nml_option name="config_tracer_advection" type="character" default_value="none" units="unitless"
		            description="Selection of the method for advecting tracers."
		            possible_values="'none'"
		/>
<!-- This option to be implemented in the future.
		<nml_option name="config_allow_additional_advance" type="logical" default_value=".true." units="none"
		            description="Determines whether ice can advance beyond its initial extent"
		            possible_values=".true. or .false."
		/>
-->
	</nml_record>


	<nml_record name="physical_parameters" in_defaults="true">
		<nml_option name="config_ice_density" type="real" default_value="910.0" units="kg m^{-3}"
		            description="ice density to use"
		            possible_values="Any positive real value"
		/>
		<nml_option name="config_ocean_density" type="real" default_value="1028.0" units="kg m^{-3}"
		            description="ocean density to use for calculating floatation"
		            possible_values="Any positive real value"
		/>
		<nml_option name="config_sea_level" type="real" default_value="0.0" units="m above datum"
		            description="sea level to use for calculating floatation"
		            possible_values="Any real value"
		/>
		<nml_option name="config_default_flowParamA" type="real" default_value="3.1709792e-24" units="s^{-1} Pa^{-n}"
		            description="Defines the default value of the flow law parameter A to be used if it is not being calculated from ice temperature.  Defaults to the SI representation of 1.0e-16 yr^{-1} Pa^{-3}."
		            possible_values="Any positive real value"
		/>
		<nml_option name="config_enhancementFactor" type="real" default_value="1.0" units="none"
			description="multiplier on the flow parameter A"
			possible_values="Any positive real value"
		/>
		<nml_option name="config_flowLawExponent" type="real" default_value="3.0" units="none"
		            description="Defines the value of the Glen flow law exponent, n."
		            possible_values="Any real value"
		/>
		<nml_option name="config_dynamic_thickness" type="real" default_value="100.0" units="m of ice"
		            description="Defines the ice thickness below which dynamics are not calculated."
		            possible_values="Any positive real value"
		/>
	</nml_record>


	<nml_record name="time_integration" in_defaults="true">
		<nml_option name="config_dt" type="character" default_value="0001-00-00_00:00:00" units="unitless"
		            description="Length of model time step defined as a time interval."
		            possible_values="Any time interval of the format 'YYYY-MM-DD_HH:MM:SS', but limited by CFL condition. (items in the format string may be dropped from the left if not needed, and the components on either side of the underscore may be replaced with a single integer representing the rightmost unit)"
		/>
		<nml_option name="config_time_integration" type="character" default_value="forward_euler" units="unitless"
		            description="Time integration method."
		            possible_values="'forward_euler'"
		/>
		<nml_option name="config_adaptive_timestep" type="logical" default_value=".false." units="unitless"
			description="Determines if the time step should be adjusted based on the CFL condition or should be steady in time. If true, the config_dt_* options are ignored."
			possible_values=".true. or .false."
		/>
		<nml_option name="config_min_adaptive_timestep" type="real" default_value="0.0" units="s"
			description="The minimum allowable time step in seconds.  If the CFL condition dictates the time step should be shorter than this, then the model aborts."
			possible_values="Any non-negative real value."
		/>
		<nml_option name="config_max_adaptive_timestep" type="real" default_value="3.15e9" units="s"
			description="The maximum allowable time step in seconds.  If the CFL condition allows the time step to be longer than this, then the model uses this value instead.  Defaults to 100 years (in seconds)."
			possible_values="Any non-negative real value."
		/>
		<nml_option name="config_adaptive_timestep_CFL_fraction" type="real" default_value="0.25" units="none"
			description="A multiplier on the minimum allowable time step calculated from the CFL condition. (Setting to 1.0 may be unstable, so smaller values are recommended.)"
			possible_values="Any positive real value less than 1.0."
		/>
		<nml_option name="config_adaptive_timestep_include_DCFL" type="logical" default_value=".false." units="none"
			description="Option of whether to include the diffusive CFL condition in the determination of the maximum allowable timestep."
			possible_values=".true. or .false."
		/>
		<nml_option name="config_adaptive_timestep_force_interval" type="character" default_value="1000-00-00_00:00:00" units="unitless"
		            description="If adaptive timestep is enabled, the model will ensure a timestep ends at multiples of this interval.  This is useful for ensuring you get output at a specific desired interval (rather than the closest time after) or for running coupled to earth system models that expect a certain interval."
		            possible_values="Any time interval of the format 'YYYY-MM-DD_HH:MM:SS'. (items in the format string may be dropped from the left if not needed, and the components on either side of the underscore may be replaced with a single integer representing the rightmost unit)"
		/>
	</nml_record>


	<nml_record name="time_management" in_defaults="true">
		<nml_option name="config_do_restart" type="logical" default_value=".false." units="unitless"
		            description="Determines if the initial conditions should be read from a restart file, or an input file.  To perform a restart, simply set this to true in the namelist.input file and modify the start time to be the time you want restart from.  A restart will read the grid information from the input field, and the restart state from the restart file.  It will perform a run normally, except velocity will not be solved on a restart."
		            possible_values=".true. or .false."
		/>
		<nml_option name="config_restart_timestamp_name" type="character" default_value="restart_timestamp" units="unitless"
		description="Path to the filename for restart timestamps to be read and written from."
		possible_values="Path to a file."
		/>
		<nml_option name="config_start_time" type="character" default_value="0000-01-01_00:00:00" units="unitless"
		            description="Timestamp describing the initial time of the simulation.  If it is set to 'file', the initial time is read from restart_timestamp"
		            possible_values="'YYYY-MM-DD_HH:MM:SS' (items in the format string may be dropped from the left if not needed, and the components on either side of the underscore may be replaced with a single integer representing the rightmost unit)"
		/>
		<nml_option name="config_stop_time" type="character" default_value="0000-01-01_00:00:00" units="unitless"
		            description="Timestamp describing the final time of the simulation. If it is set to 'none' the final time is determined from config_start_time and config_run_duration.  If config_run_duration is also specified, it takes precedence over config_stop_time.  Set config_stop_time to be equal to config_start_time (and config_run_duration to 'none') to perform a diagnostic solve only."
		            possible_values="'YYYY-MM-DD_HH:MM:SS' or 'none' (items in the format string may be dropped from the left if not needed, and the components on either side of the underscore may be replaced with a single integer representing the rightmost unit)"
		/>
		<nml_option name="config_run_duration" type="character" default_value="none" units="unitless"
		            description="Timestamp describing the length of the simulation. If it is set to 'none' the duration is determined from config_start_time and config_stop_time. config_run_duration overrides inconsistent values of config_stop_time. If a time value is specified for config_run_duration, it must be greater than 0."
		            possible_values="'YYYY-MM-DD_HH:MM:SS' or 'none' (items in the format string may be dropped from the left if not needed, and the components on either side of the underscore may be replaced with a single integer representing the rightmost unit)"
		/>
		<nml_option name="config_calendar_type" type="character" default_value="gregorian_noleap" units="unitless"
		            description="Selection of the type of calendar that should be used in the simulation."
		            possible_values="'gregorian', 'gregorian_noleap'"
		/>
	</nml_record>


	<nml_record name="io" in_defaults="true">
                <nml_option name="config_stats_interval" type="integer" default_value="0" units="unitless"
		            description="Integer specifying interval (number of timesteps) for writing global/local statistics. If set to 0, then statistics are not written (except perhaps at startup, as determined by 'config_write_stats_on_startup')."
		            possible_values="Any positive integer value greater than or equal to 0."
		/>
		<nml_option name="config_write_stats_on_startup" type="logical" default_value=".false." units="unitless"
		            description="Logical flag determining if statistics should be written prior to the first time step."
		            possible_values=".true. or .false."
                />
		<nml_option name="config_stats_cell_ID" type="integer" default_value="1" units="unitless"
		            description="global ID for the cell selected for local statistics/diagnostics"
		            possible_values="Any positive integer value greater than or equal to 0."
                />
		<nml_option name="config_write_output_on_startup" type="logical" default_value=".true." units="unitless"
		            description="Logical flag determining if an output file should be written prior to the first time step."
		            possible_values=".true. or .false."
		/>
		<nml_option name="config_pio_num_iotasks" type="integer" default_value="0" units="unitless"
		            description="Integer specifying how many IO tasks should be used within the PIO library. A value of 0 causes all MPI tasks to also be IO tasks. IO tasks are required to write contiguous blocks of data to a file."
		            possible_values="Any positive integer value greater than or equal to 0."
		/>
		<nml_option name="config_pio_stride" type="integer" default_value="1" units="unitless"
		            description="Integer specifying the stride of each IO task."
		            possible_values="Any positive integer value greater than 0."
		/>
		<nml_option name="config_year_digits" type="integer" default_value="4" units="unitless"
		            description="Integer specifying the number of digits used to represent the year in time strings."
		            possible_values="Any positive integer value greater than 0."
		/>
		<nml_option name="config_output_external_velocity_solver_data" type="logical" default_value=".false." units="unitless"
		            description="If .true., external velocity solvers (if enabled) will write their own output data in addition to any MPAS output that is configured."
		            possible_values=".true. or .false."
		/>
	</nml_record>


	<nml_record name="decomposition" in_defaults="true">
		<nml_option name="config_num_halos" type="integer" default_value="3" units="unitless"
		            description="Determines the number of halo cells extending from a blocks owned cells (Called the 0-Halo). The default of 3 is the minimum that can be used with monotonic advection."
		            possible_values="Any positive interger value."
		/>
		<nml_option name="config_block_decomp_file_prefix" type="character" default_value="graph.info.part." units="unitless"
		            description="Defines the prefix for the block decomposition file. Can include a path. The number of blocks is appended to the end of the prefix at run-time."
					possible_values="Any path/prefix to a block decomposition file."
		/>
		<nml_option name="config_number_of_blocks" type="integer" default_value="0" units="unitless"
		            description="Determines the number of blocks a simulation should be run with. If it is set to 0, the number of blocks is the same as the number of MPI tasks at run-time."
					possible_values="Any integer $>=$ 0."
		/>
		<nml_option name="config_explicit_proc_decomp" type="logical" default_value=".false." units="unitless"
		            description="Determines if an explicit processor decomposition should be used. This is only useful if multiple blocks per processor are used."
		            possible_values=".true. or .false."
		/>
		<nml_option name="config_proc_decomp_file_prefix" type="character" default_value="graph.info.part." units="unitless"
		            description="Defines the prefix for the processor decomposition file. This file is only read if config_explicit_proc_decomp is .true. The number of processors is appended to the end of the prefix at run-time."
					possible_values="Any path/prefix to a processor decomposition file."
		/>
	</nml_record>


	<nml_record name="debug" in_defaults="true">
		<nml_option name="config_print_thickness_advection_info" type="logical" default_value=".false." units="unitless"
		            description="Prints additional information about thickness advection."
		            possible_values=".true. or .false."
		/>
		<nml_option name="config_always_compute_fem_grid" type="logical" default_value=".false." units="unitless"
		            description="Always compute finite-element grid information for external dycores rather than only doing so when the ice extent changes."
		            possible_values=".true. or .false."
		/>
		<nml_option name="config_print_velocity_cleanup_details" type="logical" default_value=".false." units="unitless"
		            description="After velocity is calculated there are a few checks for appropriate values in certain geometric configurations.  Setting this option to .true. will cause detailed information about those adjustments to be printed."
		            possible_values=".true. or .false."
		/>
	</nml_record>


<!-- ======================================================================= -->
<!-- PACKAGE DEFINITIONS -->

	<packages>
		<package name="SIAvelocity" description="Variables only needed by the SIA velocity solver"/>

		<package name="higherOrderVelocity" description="This package includes variables required for higher order velocity solvers."/>

		<package name="calcDiffusivity" description="Variables only needed for calculation of apparent diffusivity."/>

	</packages>


<!-- ======================================================================= -->
<!-- I/O STREAM DEFINITIONS -->

	<streams>

		<!-- basicmesh contains all the required MPAS mesh fields - attach this to other streams as needed -->
		<stream name="basicmesh"
				type="none"
				immutable="true"
				filename_template="not-to-be-used.nc">
			<var name="latCell"/>
			<var name="lonCell"/>
			<var name="xCell"/>
			<var name="yCell"/>
			<var name="zCell"/>
			<var name="indexToCellID"/>
			<var name="latEdge"/>
			<var name="lonEdge"/>
			<var name="xEdge"/>
			<var name="yEdge"/>
			<var name="zEdge"/>
			<var name="indexToEdgeID"/>
			<var name="latVertex"/>
			<var name="lonVertex"/>
			<var name="xVertex"/>
			<var name="yVertex"/>
			<var name="zVertex"/>
			<var name="indexToVertexID"/>
			<var name="cellsOnEdge"/>
			<var name="nEdgesOnCell"/>
			<var name="nEdgesOnEdge"/>
			<var name="edgesOnCell"/>
			<var name="edgesOnEdge"/>
			<var name="weightsOnEdge"/>
			<var name="dvEdge"/>
			<var name="dcEdge"/>
			<var name="angleEdge"/>
			<var name="areaCell"/>
			<var name="areaTriangle"/>
			<var name="cellsOnCell"/>
			<var name="verticesOnCell"/>
			<var name="verticesOnEdge"/>
			<var name="edgesOnVertex"/>
			<var name="cellsOnVertex"/>
			<var name="kiteAreasOnVertex"/>
			<var name="layerThicknessFractions"/>
			<var name="meshDensity"/>
		</stream>


		<stream name="input"
				type="input"
				immutable="true"
				filename_template="landice_grid.nc"
				input_interval="initial_only">

			<stream name="basicmesh"/>
			<var name="layerThicknessFractions"/>
			<var_array name="tracers"/>
			<var name="thickness"/>
			<var name="bedTopography"/>
			<var name="sfcMassBal"/>
<!-- The following variables are used by HO only, and only enabled by the higherOrderVelocity package. -->
<!-- They do not need to be in the input file for the SIA dycore, and will be ignored if they are. -->
			<var name="beta"/>
			<var name="dirichletVelocityMask"/>
			<var name="uReconstructX"/>
			<var name="uReconstructY"/>
		</stream>

<!-- An alternate way to allow the HO variables to exist in a separate file.
		<stream name="inputHigherOrderVelocity"
				type="input"
				immutable="true"
				packages="higherOrderVelocity"
				filename_template="landice_grid.nc2"
				input_interval="initial_only">
			<var name="beta"/>
			<var name="dirichletVelocityMask"/>
			<var name="dirichletVelocityXValue"/>
			<var name="dirichletVelocityYValue"/>
		</stream>
-->


		<stream name="restart"
				type="input;output"
				immutable="true"
				filename_template="restart.$Y-$M-$D_$h.$m.$s.nc"
				filename_interval="output_interval"
				input_interval="initial_only"
				output_interval="0010-00-00_00:00:00"
				reference_time="0000-01-01_00:00:00"
				precision="double"
				clobber_mode="replace_files">

			<stream name="basicmesh"/>
			<var name="layerThicknessFractions"/>
			<var_array name="tracers"/>
			<var name="xtime"/>
			<var name="thickness"/>
			<var name="cellMask"/>
			<var name="bedTopography"/>
			<var name="sfcMassBal"/>
			<!-- normalVelocity is needed for advection on the next timestep -->
			<var name="normalVelocity"/>
			<!-- uReconstructX/Y are only needed for exact restarts of HO iterative solvers (once packages can be attached to variables, these can be set to the higherOrderVelocity package) -->
			<var name="uReconstructX"/>
			<var name="uReconstructY"/>
			<!-- beta is only needed for HO solvers (once packages can be attached to variables, these can be set to the higherOrderVelocity package) -->
			<var name="beta"/>
		</stream>


		<stream name="output"
				type="output"
				filename_template="output.nc"
				filename_interval="none"
				output_interval="0001-00-00_00:00:00"
				runtime_format="single_file"
				reference_time="0000-01-01_00:00:00"
				precision="double"
				clobber_mode="replace_files">
				<!-- Note: I had set the default precision to 'single', but MpasDraw currently only supports double precision files -->

			<stream name="basicmesh"/>
			<var name="layerThicknessFractions"/>
			<var name="layerCenterSigma"/>
			<var name="layerInterfaceSigma"/>
			<var_array name="tracers"/>
			<var name="xtime"/>
			<var name="thickness"/>
			<var name="lowerSurface"/>
			<var name="upperSurface"/>
			<var name="cellMask"/>
			<var name="edgeMask"/>
			<var name="vertexMask"/>
			<var name="normalVelocity"/>
			<var name="uReconstructX"/>
			<var name="uReconstructY"/>
		</stream>

	</streams>


<!-- ======================================================================= -->
<!-- INTERNAL MODEL VARIABLES -->

<!-- Note: by default, all MPAS-LI variables have only one time level.  There
are/will be some variables that require a second time level, and they are/can be
individually specified to have a second time level.  Within the code, all routines
assume there is only one time level, except where explicitly needed otherwise.
Therefore, to minimize confusion, the convention is that the current time to be
computed on is always time level 1.  And time level 2, if it exists for a variable,
is the value of that variable from the *previous* time level!
 -->


	<!-- Mesh Variables required by MPAS framework -->
	<var_struct name="mesh" time_levs="1">
		<!-- The following fields are part of the MPAS mesh spec. -->
		<var name="latCell" type="real" dimensions="nCells" units="radians"
			 description="Latitude location of cell centers in radians."
		/>
		<var name="lonCell" type="real" dimensions="nCells" units="radians"
		     description="Longitude location of cell centers in radians."
		/>
		<var name="xCell" type="real" dimensions="nCells" units="unitless"
		     description="X Coordinate in cartesian space of cell centers."
		/>
		<var name="yCell" type="real" dimensions="nCells" units="unitless"
		     description="Y Coordinate in cartesian space of cell centers."
		/>
		<var name="zCell" type="real" dimensions="nCells" units="unitless"
		     description="Z Coordinate in cartesian space of cell centers."
		/>
		<var name="indexToCellID" type="integer" dimensions="nCells" units="unitless"
		     description="List of global cell IDs."
		/>
		<var name="latEdge" type="real" dimensions="nEdges" units="radians"
		     description="Latitude location of edge midpoints in radians."
		/>
		<var name="lonEdge" type="real" dimensions="nEdges" units="radians"
		     description="Longitude location of edge midpoints in radians."
		/>
		<var name="xEdge" type="real" dimensions="nEdges" units="unitless"
		     description="X Coordinate in cartesian space of edge midpoints."
		/>
		<var name="yEdge" type="real" dimensions="nEdges" units="unitless"
		     description="Y Coordinate in cartesian space of edge midpoints."
		/>
		<var name="zEdge" type="real" dimensions="nEdges" units="unitless"
		     description="Z Coordinate in cartesian space of edge midpoints."
		/>
		<var name="indexToEdgeID" type="integer" dimensions="nEdges" units="unitless"
		     description="List of global edge IDs."
		/>
		<var name="latVertex" type="real" dimensions="nVertices" units="radians"
		     description="Latitude location of vertices in radians."
		/>
		<var name="lonVertex" type="real" dimensions="nVertices" units="radians"
		     description="Longitude location of vertices in radians."
		/>
		<var name="xVertex" type="real" dimensions="nVertices" units="unitless"
		     description="X Coordinate in cartesian space of vertices."
		/>
		<var name="yVertex" type="real" dimensions="nVertices" units="unitless"
		     description="Y Coordinate in cartesian space of vertices."
		/>
		<var name="zVertex" type="real" dimensions="nVertices" units="unitless"
		     description="Z Coordinate in cartesian space of vertices."
		/>
		<var name="indexToVertexID" type="integer" dimensions="nVertices" units="unitless"
		     description="List of global vertex IDs."
		/>
		<var name="nEdgesOnCell" type="integer" dimensions="nCells" units="unitless"
		     description="Number of edges that border each cell."
		/>
		<var name="nEdgesOnEdge" type="integer" dimensions="nEdges" units="unitless"
		     description="Number of edges that surround each of the cells that straddle each edge. These edges are used to reconstruct the tangential velocities."
		/>
		<var name="cellsOnEdge" type="integer" dimensions="TWO nEdges" units="unitless"
		     description="List of cells that straddle each edge."
		/>
		<var name="edgesOnCell" type="integer" dimensions="maxEdges nCells" units="unitless"
		     description="List of edges that border each cell."
		/>
		<var name="edgesOnEdge" type="integer" dimensions="maxEdges2 nEdges" units="unitless"
		     description="List of edges that border each of the cells that straddle each edge."
		/>
		<var name="cellsOnCell" type="integer" dimensions="maxEdges nCells" units="unitless"
		     description="List of cells that neighbor each cell."
		/>
		<var name="verticesOnCell" type="integer" dimensions="maxEdges nCells" units="unitless"
		     description="List of vertices that border each cell."
		/>
		<var name="verticesOnEdge" type="integer" dimensions="TWO nEdges" units="unitless"
		     description="List of vertices that straddle each edge."
		/>
		<var name="edgesOnVertex" type="integer" dimensions="vertexDegree nVertices" units="unitless"
		     description="List of edges that share a vertex as an endpoint."
		/>
		<var name="cellsOnVertex" type="integer" dimensions="vertexDegree nVertices" units="unitless"
		     description="List of cells that share a vertex."
		/>
		<var name="weightsOnEdge" type="real" dimensions="maxEdges2 nEdges" units="unitless"
		     description="Reconstruction weights associated with each of the edgesOnEdge."
		/>
		<var name="dvEdge" type="real" dimensions="nEdges" units="m"
		     description="Length of each edge, computed as the distance between verticesOnEdge."
		/>
		<var name="dcEdge" type="real" dimensions="nEdges" units="m"
		     description="Length of each edge, computed as the distance between cellsOnEdge."
		/>
		<var name="angleEdge" type="real" dimensions="nEdges" units="radians"
		     description="Angle the edge normal makes with local eastward direction."
		/>
		<var name="areaCell" type="real" dimensions="nCells" units="m^2"
		     description="Area of each cell in the primary grid."
		/>
		<var name="areaTriangle" type="real" dimensions="nVertices" units="m^2"
		     description="Area of each cell (triangle) in the dual grid."
		/>
		<var name="kiteAreasOnVertex" type="real" dimensions="vertexDegree nVertices" units="m^2"
		     description="Area of the portions of each dual cell that are part of each cellsOnVertex."
		/>
		<var name="meshDensity" type="real" dimensions="nCells" units="unitless"
		     description="The value of the generating density function at each cell center."
		/>
		<!-- The following fields are expected by some operators but not formally part of the MPAS mesh spec. -->
		<!-- They are not input by the model but calculated internally. -->
		<var name="localVerticalUnitVectors" type="real" dimensions="R3 nCells" units="unitless"
		     description="Unit surface normal vectors defined at cell centers."
		/>
		<var name="edgeNormalVectors" type="real" dimensions="R3 nEdges" units="unitless"
		     description="Normal vector defined at an edge."
		/>
		<var name="cellTangentPlane" type="real" dimensions="R3 TWO nCells" units="unitless"
		     description="The two vectors that define a tangent plane at a cell center."
		/>
		<var name="coeffs_reconstruct" type="real" dimensions="R3 maxEdges nCells" units="unitless"
		     description="Coefficients to reconstruct velocity vectors at cell centers."
		/>
		<!-- The following field is required as input by MPAS-LI -->
		<var name="layerThicknessFractions" type="real" dimensions="nVertLevels" units="none"
		     description="Fractional thickness of each sigma layer"
		/>
		<!-- The following fields are required by MPAS-LI but are calculated internally -->
		<var name="layerCenterSigma" type="real" dimensions="nVertLevels" units="none"
		     description="Sigma (fractional) level at center of each layer"
		/>
		<var name="layerInterfaceSigma" type="real" dimensions="nVertInterfaces" units="none"
		     description="Sigma (fractional) level at interface between each layer (including top and bottom)"
		/>
		<var name="edgeSignOnCell" type="integer" dimensions="maxEdges nCells" units="unitless"
		     description="Sign of edge contributions to a cell for each edge on cell. Used for bit-reproducible loops. Represents directionality of vector connecting cells."
		/>
		<var name="edgeSignOnVertex" type="integer" dimensions="maxEdges nVertices" units="unitless"
		     description="Sign of edge contributions to a vertex for each edge on vertex. Used for bit-reproducible loops. Represents directionality of vector connecting vertices."
		/>
		<!-- Variables only needed by SIA solver -->
		<var name="baryCellsOnVertex" type="integer" dimensions="R3 nVertices" units="unitless"
			 description="Cell center indices to use for interpolating from cell centers to vertex locations.  Note these are local indices!" packages="SIAvelocity"
		/>
		<var name="baryWeightsOnVertex" type="real" dimensions="R3 nVertices" units="unitless"
			 description="Weights to interpolate from cell centers to vertex locations.  Each weight is used with the corresponding cell center index indentified by baryCellsOnVertex." packages="SIAvelocity"
		/>
		<!-- time-related fields have to go somewhere.  "mesh" is a more general place than the other pools -->
		<var name="xtime" type="text" time_levs="1" dimensions="Time" units="unitless"
		     description="model time, with format 'YYYY-MM-DD_HH:MM:SS'"
		/>
		<var name="deltat" type="real" time_levs="1" dimensions="Time" units="s"
		     description="time step length, in seconds.  Value on a given time is the value used between the previous time level and the current time level."
		/>
		<var name="allowableDtACFL" type="real" time_levs="1" dimensions="Time" units="s"
		     description="The maximum allowable time step based on the advective CFL condition.  Value on a given time is the value appropriate for  between the previous time level and the current time level."
		/>
		<var name="allowableDtDCFL" type="real" time_levs="1" dimensions="Time" units="s"
		     description="The maximum allowable time step based on the diffusive CFL condition.  Value on a given time is the value appropriate for  between the previous time level and the current time level."
		/>
	</var_struct>

<!-- ================ -->

	<!--  Variables related to ice sheet geometry -->
	<var_struct name="geometry" time_levs="1">
		<var name="bedTopography" type="real" dimensions="nCells Time" units="m above datum"
		     description="Elevation of ice sheet bed.  Once isostasy is added to the model, this should become a state variable."
		/>
		<var name="thickness" type="real" dimensions="nCells Time" units="m" time_levs="1"
		     description="ice thickness"
		/>
		<var name="layerThickness" type="real" dimensions="nVertLevels nCells Time" units="m" time_levs="2"
		     description="layer thickness"
		/>
		<var name="lowerSurface" type="real" dimensions="nCells Time" units="m above datum"
		     description="elevation at bottom of ice"
		/>
		<var name="upperSurface" type="real" dimensions="nCells Time" units="m above datum"
		     description="elevation at top of ice"
		/>
		<var name="layerThicknessEdge" type="real" dimensions="nVertLevels nEdges Time" units="m"
		     description="layer thickness on cell edges"
		/>
		<var name="cellMask" type="integer" dimensions="nCells Time" units="none"
		     description="bitmask indicating various properties about the ice sheet on cells.  cellMask only needs to be a restart field if config_allow_additional_advance = false (to keep the mask of initial ice extent)"
		/>
		<var name="edgeMask" type="integer" dimensions="nEdges Time" units="none"
		     description="bitmask indicating various properties about the ice sheet on edges."
		/>
		<var name="vertexMask" type="integer" dimensions="nVertices Time" units="none" time_levs="2"
		     description="bitmask indicating various properties about the ice sheet on vertices."
		/>
		<!-- Note vertexMask has two time level to easily check if it changes - this is only used by the HO dycores -->

		<var name="sfcMassBal" type="real" dimensions="nCells Time" units="kg m^{-2} s^{-1}"
		     description="Surface mass balance"
		/>
		<var name="basalMassBal" type="real" dimensions="nCells Time" units="kg m^{-2} s^{-1}"
		     description="Basal mass balance"
		/>

		<!-- Variables only needed by SIA solver or for calculating diffusivity -->
		<var name="upperSurfaceVertex" type="real" dimensions="nVertices Time" units="m above datum"
		     description="elevation at top of ice on vertices" packages="SIAvelocity"
		/>
		<var name="normalSlopeEdge"            type="real"     dimensions="nEdges Time"
		     units="m m^{-1}"  description="normal surface slope on edges" packages="SIAvelocity;calcDiffusivity"
		/>
		<var name="tangentSlopeEdge"            type="real"     dimensions="nEdges Time"
		     units="m m^{-1}"  description="tangent surface slope on edges" packages="SIAvelocity"
		/>
		<var name="slopeEdge"            type="real"     dimensions="nEdges Time"
		     units="m m^{-1}"  description="surface slope magnitude on edges" packages="SIAvelocity"
		/>

		<!-- Variables only needed for calculating diffusivity at cell centers -->
		<var name="apparentDiffusivity" type="real" dimensions="nCells Time" units="m^2 s^{-1}"
			description="apparent diffusivity at cell centers"
		/>
	</var_struct>

<!-- ================ -->

	<!-- Variables related to velocity -->
	<var_struct name="velocity" time_levs="1">
		<var name="flowParamA" type="real" dimensions="nVertLevels nCells Time" units="s^{-1} Pa^{-n}"
		     description="flow law parameter, A"
		/>
		<var name="normalVelocity" type="real" dimensions="nVertInterfaces nEdges Time" units="m s^{-1}"
		     description="horizonal velocity, normal component to an edge"
		/>
		<var name="uReconstructX"                     type="real"     dimensions="nVertInterfaces nCells Time"
		     units="m s^{-1}"  description="x-component of velocity reconstructed on cell centers.  Also, for higher-order dycores, on input: value of the x-component of velocity that should be applied where dirichletVelocityMask==1."
		/>
		<var name="uReconstructY"                     type="real"     dimensions="nVertInterfaces nCells Time"
		     units="m s^{-1}"  description="y-component of velocity reconstructed on cell centers.    Also, for higher-order dycores, on input: value of the y-component of velocity that should be applied where dirichletVelocityMask==1."
		/>
		<var name="uReconstructZ"                     type="real"     dimensions="nVertInterfaces nCells Time"
		     units="m s^{-1}"  description="z-component of velocity reconstructed on cell centers"
		/>
		<var name="uReconstructZonal"                 type="real"     dimensions="nVertInterfaces nCells Time"
		     units="m s^{-1}"  description="zonal velocity reconstructed on cell centers"
		/>
		<var name="uReconstructMeridional"            type="real"     dimensions="nVertInterfaces nCells Time"
		     units="m s^{-1}"  description="meridional velocity reconstructed on cell centers"
		/>
		<var name="surfaceSpeed"                     type="real"     dimensions="nCells Time"
		     units="m s^{-1}"  description="ice surface speed reconstructed at cell centers"
		/>
		<var name="basalSpeed"                     type="real"     dimensions="nCells Time"
		     units="m s^{-1}"  description="ice basal speed reconstructed at cell centers"
		/>

		<!-- Variables only needed by HO solver -->
		<var name="beta" type="real" dimensions="nCells Time" units="Pa s m^{−1}"
		     description="higher-order basal traction parameter"
			packages="higherOrderVelocity"
		/>
		<var name="betaSolve" type="real" dimensions="nCells Time" units="Pa s m^{−1}"
		     description="higher-order basal traction parameter"
			packages="higherOrderVelocity"
		/>
		<var name="anyDynamicVertexMaskChanged"              type="integer"  dimensions="Time"
		     units="none"  description="flag needed by external velocity solvers that indicates if the region to solve on the block's domain has changed (treated as a logical)"
			packages="higherOrderVelocity"
		/>
		<var name="dirichletVelocityMask"            type="integer"     dimensions="nVertInterfaces nCells Time"
			units="none"  time_levs="2"
			description="mask of where Dirichlet boundary conditions should be applied to the velocity solution.  1 means apply a Dirichlet boundary condition, 0 means do not. (higher-order dycores only)"
			packages="higherOrderVelocity"
		/>
		<var name="dirichletMaskChanged"              type="integer"  dimensions="Time"
		     units="none"  description="flag needed by external velocity solvers that indicates if the Dirichlet boundary condition mask has changed (treated as a logical)"
			packages="higherOrderVelocity"
		/>
		<var name="floatingEdges"
			type="integer" dimensions="nEdges Time"
			units="unitless"
			description="edges which are floating have a value of 1.  non floating edges have a value of 0."
			packages="higherOrderVelocity"
		/>
	</var_struct>

<!-- ================ -->

	<!-- Variables related to thermal state -->
	<var_struct name="thermal" time_levs="1">
		<var name="basalTemperature" type="real" dimensions="nCells Time" units="K"
		     description="lower surface ice temperature"
		/>
		<var_array name="tracers" type="real" dimensions="nVertLevels nCells Time">
			<var name="temperature" array_group="dynamics" units="K"
			     description="interior ice temperature"
			/>
		</var_array>
		<!-- Note: putting tracers in this pool is a bit awkward since additional tracers may not be thermally-related -->
		<var name="surfaceTemperature" type="real" dimensions="nCells Time" units="K"
		     description="upper surface ice temperature"
		/>
		<var name="basalHeatFlux" type="real" dimensions="nCells Time" units="W m^{-2}"
		     description="basal heat flux into the ice (positive upward)"
		/>
	</var_struct>

<!-- ================ -->

	<!-- Tendency Variables --> 
	<var_struct name="tendency" time_levs="1">
		<var name="tend_layerThickness" type="real" dimensions="nVertLevels nCells Time" units="m s^{-1}" name_in_code="layerThickness"
		     description="time tendency of layer thickness"
		/>
		<var_array name="tendTracers" type="real" dimensions="nVertLevels nCells Time" name_in_code="tracers">
			<var name="tend_temperature" array_group="dynamics" units="K s^{-1}" name_in_code="temperature"
			     description="time tendency of ice temperature"
			/>
		</var_array>
	</var_struct>

<!-- ================ -->

	<!-- Scratch Variables -->
	<var_struct name="scratch" time_levs="1">
	  <var name="iceCellMask" type="integer" dimensions="nCells" units="none"
	       description="mask set to 1 in cells where ice is present and 0 otherwise"
	       persistence="scratch"
	       />
	  <var name="iceEdgeMask" type="integer" dimensions="nEdges" units="none"
	       description="mask set to 1 for edges adjacent to ice-covered cells and 0 otherwise"
	       persistence="scratch"
	       />
	  <var name="workLevelCell" type="real" dimensions="nVertLevels nCells" units="none"
	       description="generic work array with dimensions of (nVertLevels nCells)"
	       persistence="scratch"
	       />
	  <var name="workCell" type="real" dimensions="nCells" units="none"
	       description="generic work array with dimensions of (nCells)"
	       persistence="scratch"
	       />
	  <var name="workCell2" type="real" dimensions="nCells" units="none"
	       description="generic work array with dimensions of (nCells)"
	       persistence="scratch"
	       />
	  <var name="workCell3" type="real" dimensions="nCells" units="none"
	       description="generic work array with dimensions of (nCells)"
	       persistence="scratch"
	       />
	  <var name="slopeCellX" type="real" dimensions="nCells" units="none"
	       descriptiom="x-component of slope on cell centers"
	       persistence="scratch"
	       />
	  <var name="slopeCellY" type="real" dimensions="nCells" units="none"
	       descriptiom="y-component of slope on cell centers"
	       persistence="scratch"
	       />
	  <var name="vertexIndices" type="integer" dimensions="nVertices" units="none"
	       description="local indices of each vertex"
	       persistence="scratch"
	       />
	</var_struct>

<!-- ======================================================================= -->


</registry>
